<!DOCTYPE HTML>
<html lang="zh-CN">
    <!-- shw2018 洪卫  modify 2019.08.15-->



<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Spring Boot, Spring Cloud, 微服务, Java技术, 好好学java, Java面试, 分布式, 最新干货分享">
    <meta name="baidu-site-verification" content="fmlEuI34ir" />
    <meta name="google-site-verification" content="ZWVq5UvPg33BCEA3LRTUkYe5J854o9lF1_WRTer9l8A" />
    <meta name="description" content="本站是 好好学java 的技术分享博客。内容涵盖Java后端技术、Spring Boot、Spring Cloud、微服务架构、分布式、Java面试、测试开发等相关的研究与知识分享。">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>5W 字的 Linux 知识总结 | 好好学java | Spring Boot | Spring Cloud | 微服务 | Java技术 | Java面试 | 分布式 | 最新干货分享</title>
    <link rel="icon" type="image/png" href="http://image.ouyangsihai.cn/FjihsEiBMONnJIRtPwgGkjE4HAP7">

    <!-- <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"> -->
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <!-- 自定义fontawesome样式：欧阳思海 -->
    <link rel="stylesheet" type="text/css" href="/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/css/brands.min.css">
    <link rel="stylesheet" type="text/css" href="/css/fontawesome.min.css">
    <link rel="stylesheet" type="text/css" href="/css/regular.min.css">
    <link rel="stylesheet" type="text/css" href="/css/solid.min.css">


    <style type="text/css">
        code[class*="language-"],
            pre[class*="language-"] {
                white-space: pre !important;
            }

            

        /* 将matery.css中的背景颜色修改放到这里：欧阳思海 */
        .bg-color {
            background-image: linear-gradient(to right, #ec8585 0%, #419488 100%);
            opacity: 0.9;
            // 透明度
        }
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>

    
    
    <script>
        (function () {
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>
    

    <script>
        var _hmt = _hmt || [];
        (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?6fe466069710c03a563713b507fbaca7";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
        })();
    </script>


    <!-- Google Analytics -->
    <script>
        (function (i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date(); a = s.createElement(o),
                m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
        })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

        ga('create', 'UA-XXXXX-Y', 'auto');
        ga('send', 'pageview');
    </script>
    <!-- End Google Analytics -->

    <script>(function (i, s, o, g, r, a, m) { i["DaoVoiceObject"] = r; i[r] = i[r] || function () { (i[r].q = i[r].q || []).push(arguments) }, i[r].l = 1 * new Date(); a = s.createElement(o), m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; a.charset = "utf-8"; m.parentNode.insertBefore(a, m) })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0a804bac.js", "daovoice")</script>

    <script>
        if (true) {
            daovoice('init', {
                app_id: "0a804bac",
                user_id: "NO_89757", // 必填: 该用户在您系统上的唯一ID
                email: "daovoice@example.com", // 选填:  该用户在您系统上的主邮箱
                name: "道客船长", // 选填: 用户名
                signed_up: 1449821660 // 选填: 用户的注册时间，用Unix时间戳表示
            });
            daovoice('update');

            daovoice('init', {
                app_id: "0a804bac"
            });
            daovoice('update');
        }
    </script>
<meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/rss2.xml" title="好好学java" type="application/rss+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

    <body>

        <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="http://image.ouyangsihai.cn/FjihsEiBMONnJIRtPwgGkjE4HAP7" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span" style="font-size: 1.4rem;">好好学java</span>
                </a>
            </div>
            


<!-- <a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="" class="waves-effect waves-light">
            
            <i class="fa "></i>
            
            <span></span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title=""></i>
        </a>
    </li>
</ul> -->

<!-- 支持二级菜单特性 洪卫 shw2018 modify 2019.09.17  -->
<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-align-justify"></i></a>
<ul class="right nav-menu">
    
      <li class="hide-on-med-and-down nav-item" >

        
              <a href="/categories/" class="waves-effect waves-light">
                
                  <i style="font-size: 1.1rem;" class="fa fa-folder-minus"></i>
                
                <span style="font-size: 1.1rem;">Java学习</span>
                <i style="font-size: 1.1rem;" class="fa fa-chevron-down" aria-hidden="true"></i>
              </a>

            <ul class="sub-nav menus_item_child ">
              
                <li> 
                  <a href="/categories/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/" >
                    
                    <span>Java入门</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/Javaweb/" >
                    
                    <span>Java Web</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/spring%E6%95%99%E7%A8%8B/" >
                    
                    <span>Spring教程</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/springboot%E6%95%99%E7%A8%8B/" >
                    
                    <span>SpringBoot教程</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/springcloud%E6%95%99%E7%A8%8B/" >
                    
                    <span>SpringCloud教程</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/" >
                    
                    <span>Java面试</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/%E5%89%91%E6%8C%87offer/" >
                    
                    <span>剑指offer</span>
                  </a>
                </li>
               
            </ul>
          
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
              <a href="/categories/" class="waves-effect waves-light">
                
                  <i style="font-size: 1.1rem;" class="fa fa-code-branch"></i>
                
                <span style="font-size: 1.1rem;">Java进阶</span>
                <i style="font-size: 1.1rem;" class="fa fa-chevron-down" aria-hidden="true"></i>
              </a>

            <ul class="sub-nav menus_item_child ">
              
                <li> 
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97/" >
                    
                    <span>设计模式</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" >
                    
                    <span>Java并发编程</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/" >
                    
                    <span>数据库</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/redis/" >
                    
                    <span>Redis</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/linux/" >
                    
                    <span>Linux</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/" >
                    
                    <span>Java实战项目</span>
                  </a>
                </li>
               
            </ul>
          
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
              <a href="/categories/" class="waves-effect waves-light">
                
                  <i style="font-size: 1.1rem;" class="fa fa-code"></i>
                
                <span style="font-size: 1.1rem;">python学习</span>
                <i style="font-size: 1.1rem;" class="fa fa-chevron-down" aria-hidden="true"></i>
              </a>

            <ul class="sub-nav menus_item_child ">
              
                <li> 
                  <a href="/categories/python%E5%9F%BA%E7%A1%80/" >
                    
                    <span>python基础</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/python%E6%A1%86%E6%9E%B6/" >
                    
                    <span>python框架</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/python%E5%85%B6%E4%BB%96/" >
                    
                    <span>python其他</span>
                  </a>
                </li>
               
            </ul>
          
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
              <a href="/categories/" class="waves-effect waves-light">
                
                  <i style="font-size: 1.1rem;" class="fa fa-coffee"></i>
                
                <span style="font-size: 1.1rem;">Java扩展</span>
                <i style="font-size: 1.1rem;" class="fa fa-chevron-down" aria-hidden="true"></i>
              </a>

            <ul class="sub-nav menus_item_child ">
              
                <li> 
                  <a href="/categories/dubbo/" >
                    
                    <span>dubbo</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/netty/" >
                    
                    <span>netty</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/rpc/" >
                    
                    <span>rpc</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/eureka/" >
                    
                    <span>eureka</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" >
                    
                    <span>中间件</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" >
                    
                    <span>分布式</span>
                  </a>
                </li>
               
            </ul>
          
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
              <a href="/categories/" class="waves-effect waves-light">
                
                  <i style="font-size: 1.1rem;" class="fa fa-desktop"></i>
                
                <span style="font-size: 1.1rem;">计算机核心</span>
                <i style="font-size: 1.1rem;" class="fa fa-chevron-down" aria-hidden="true"></i>
              </a>

            <ul class="sub-nav menus_item_child ">
              
                <li> 
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" >
                    
                    <span>数据结构</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/leetcode%E5%88%B7%E9%A2%98/" >
                    
                    <span>leetcode刷题</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" >
                    
                    <span>计算机网络</span>
                  </a>
                </li>
              
                <li> 
                  <a href="/categories/%E7%AE%97%E6%B3%95/" >
                    
                    <span>算法</span>
                  </a>
                </li>
               
            </ul>
          
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/categories/" class="waves-effect waves-light">
              
                <i style="font-size: 1.1rem;" class="fa fa-adjust"></i>
              
              <span style="font-size: 1.1rem;">学习资源</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/contact" class="waves-effect waves-light">
              
                <i style="font-size: 1.1rem;" class="fa fa-envelope"></i>
              
              <span style="font-size: 1.1rem;">留言</span>
            </a>

            
      </li>
    

    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>

</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="http://image.ouyangsihai.cn/FjihsEiBMONnJIRtPwgGkjE4HAP7" class="logo-img circle responsive-img">
        
        <div class="logo-name">好好学java</div>
        <div class="logo-desc">
            
            
            本站是 好好学java 的技术分享博客，涵盖Java后端技术、SpringBoot、微服务架构、分布式、Java面试等知 ...
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa fa-fw fa-folder-minus"></i>
			
			Java学习
			<span class="m-icon"><i class="fa fa-chevron-right"></i></span>
		</a>
            <ul  >
              
                <li>   
				
                  <a href="/categories/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/ " style="margin-left:75px";>
				  
		          <span>Java入门</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Javaweb/ " style="margin-left:75px";>
				  
		          <span>Java Web</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/spring%E6%95%99%E7%A8%8B/ " style="margin-left:75px";>
				  
		          <span>Spring教程</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/springboot%E6%95%99%E7%A8%8B/ " style="margin-left:75px";>
				  
		          <span>SpringBoot教程</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/springcloud%E6%95%99%E7%A8%8B/ " style="margin-left:75px";>
				  
		          <span>SpringCloud教程</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/ " style="margin-left:75px";>
				  
		          <span>Java面试</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/%E5%89%91%E6%8C%87offer/ " style="margin-left:75px";>
				  
		          <span>剑指offer</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa fa-fw fa-code-branch"></i>
			
			Java进阶
			<span class="m-icon"><i class="fa fa-chevron-right"></i></span>
		</a>
            <ul  >
              
                <li>   
				
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97/ " style="margin-left:75px";>
				  
		          <span>设计模式</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ " style="margin-left:75px";>
				  
		          <span>Java并发编程</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/ " style="margin-left:75px";>
				  
		          <span>数据库</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/redis/ " style="margin-left:75px";>
				  
		          <span>Redis</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/linux/ " style="margin-left:75px";>
				  
		          <span>Linux</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/ " style="margin-left:75px";>
				  
		          <span>Java实战项目</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa fa-fw fa-code"></i>
			
			python学习
			<span class="m-icon"><i class="fa fa-chevron-right"></i></span>
		</a>
            <ul  >
              
                <li>   
				
                  <a href="/categories/python%E5%9F%BA%E7%A1%80/ " style="margin-left:75px";>
				  
		          <span>python基础</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/python%E6%A1%86%E6%9E%B6/ " style="margin-left:75px";>
				  
		          <span>python框架</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/python%E5%85%B6%E4%BB%96/ " style="margin-left:75px";>
				  
		          <span>python其他</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa fa-fw fa-coffee"></i>
			
			Java扩展
			<span class="m-icon"><i class="fa fa-chevron-right"></i></span>
		</a>
            <ul  >
              
                <li>   
				
                  <a href="/categories/dubbo/ " style="margin-left:75px";>
				  
		          <span>dubbo</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/netty/ " style="margin-left:75px";>
				  
		          <span>netty</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/rpc/ " style="margin-left:75px";>
				  
		          <span>rpc</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/eureka/ " style="margin-left:75px";>
				  
		          <span>eureka</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/ " style="margin-left:75px";>
				  
		          <span>中间件</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/ " style="margin-left:75px";>
				  
		          <span>分布式</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa fa-fw fa-desktop"></i>
			
			计算机核心
			<span class="m-icon"><i class="fa fa-chevron-right"></i></span>
		</a>
            <ul  >
              
                <li>   
				
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ " style="margin-left:75px";>
				  
		          <span>数据结构</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/leetcode%E5%88%B7%E9%A2%98/ " style="margin-left:75px";>
				  
		          <span>leetcode刷题</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ " style="margin-left:75px";>
				  
		          <span>计算机网络</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/%E7%AE%97%E6%B3%95/ " style="margin-left:75px";>
				  
		          <span>算法</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/" class="waves-effect waves-light">
			
			    <i class="fa fa-fw fa-adjust"></i>
			
			学习资源
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa fa-fw fa-envelope"></i>
			
			留言
		</a>
          
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

        



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/4.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        5W 字的 Linux 知识总结
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }

    /* 自定义mycard：欧阳思海 */

    #my-card {
        /* position: relative; */
        width: 310px;
        height: 300px;
        /* max-height: 330px; */
        margin-bottom: 15px;
        margin-top: 15px;
        /* text-align: center; */
        border: 0;
        border-radius: 3px;
        color: rgba(0, 0, 0, .87);
        background: #fff 50%;
        background-image: none;
        background-size: auto;
        background-size: cover;
        box-shadow: 0 15px 35px rgba(50, 50, 93, .1), 0 5px 15px rgba(0, 0, 0, .07);
    }

    /* .widget {
        line-height: 1.6em;
        word-wrap: break-word;
        font-size: 0.9em;
        padding-top: 15px;
        padding-left: -45px;
    } */
</style>




<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- shw2018 洪卫  modify 2019.08.15-->

<!-- 代码块修改的代码开始 -->
<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFunction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

<!-- 代码块修改代码结束 -->


<!-- 文章内容详情 -->
<div id="container">
    <div id="artDetail">
        <div class="card">
            <div class="card-content article-info">
                <div class="row tag-cate">
                    <div class="col s7">
                        
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                        
                    </div>
                    <div class="col s5 right-align">
                        
                        <div class="post-cate">
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%A5%BD%E5%A5%BD%E5%AD%A6java/" class="post-category" target="_blank">
                                好好学java
                            </a>
                            
                        </div>
                        
                    </div>
                </div>

                <div class="post-info">
                    <div class="post-date info-break-policy">
                        <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                        2021-04-04
                    </div>

                    <div class="post-author info-break-policy">
                        <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                        
                        欧阳思海
                        
                    </div>

                    
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        38k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        133 分
                    </div>
                    
                    

                    
                    <span id="busuanzi_container_site_pv" style='display:none'></span>
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>

                    

                </div>
            </div>
            <hr class="clearfix">
            <div class="card-content article-card-content">
                <!-- 欧阳思海，modify，2020.05.01-->
<!-- 文章详情详情页面的头部广告位置信息 -->
<div id="post-head-panel">
    
    <a href="https://github.com/OUYANGSIHAI/JavaInterview" style="font-size: 18px;" target="_blank">
        <img src="/icons/hot.gif">
        本人花费半年的时间总结的《Java面试指南》已拿腾讯等大厂offer，已开源在github ，欢迎star！
    </a>
    
    
</div>
<br />



<blockquote>
    
            <p>本文GitHub <a href="https://github.com/OUYANGSIHAI/JavaInterview" target="_blank">https://github.com/OUYANGSIHAI/JavaInterview</a> 已收录，这是我花了6个月总结的<b>一线大厂Java面试</b>总结，本人已拿大厂offer，欢迎star</p>
    
    <p>原文链接：blog.ouyangsihai.cn &gt;&gt; <a href="/5w-zi-de-linux-zhi-shi-zong-jie.html" target="_blank">5W 字的 Linux 知识总结</a></p>
</blockquote>
                <div id="articleContent">
                    <p>点击上方 **好好学java **，选择 **星标 **公众号</p>
<h4 id="重磅资讯、干货，第一时间送达"><a href="#重磅资讯、干货，第一时间送达" class="headerlink" title="重磅资讯、干货，第一时间送达"></a><pre class="has"><code class="language-php">重磅资讯、干货，第一时间送达</h4><p></code></pre></p>
<h2 id="今日推荐："><a href="#今日推荐：" class="headerlink" title="今日推荐："></a><strong><strong>今日推荐：</strong></strong></h2><h4 id="个人原创100W-访问量博客：点击前往，查看更多"><a href="#个人原创100W-访问量博客：点击前往，查看更多" class="headerlink" title="个人原创100W+访问量博客：点击前往，查看更多"></a><pre class="has"><code class="language-php">个人原创100W+访问量博客：点击前往，查看更多</h4><p></code></pre></p>
<p>Linux 简介</p>
<p>UNIX 是一个交互式系统，用于同时处理多进程和多用户同时在线。为什么要说 UNIX，那是因为 Linux 是由 UNIX 发展而来的，UNIX 是由程序员设计，它的主要服务对象也是程序员。Linux 继承了 UNIX 的设计目标。从智能手机到汽车，超级计算机和家用电器，从家用台式机到企业服务器，Linux 操作系统无处不在。</p>
<p>大多数程序员都喜欢让系统尽量简单，优雅并具有一致性。举个例子，从最底层的角度来讲，一个文件应该只是一个字节集合。为了实现顺序存取、随机存取、按键存取、远程存取只能是妨碍你的工作。相同的，如果命令</p>
<pre class="line-numbers language-java"><code class="language-java">
ls A<span class="token operator">*</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>意味着只列出以 A 为开头的所有文件，那么命令</p>
<pre class="line-numbers language-java"><code class="language-java">
rm A<span class="token operator">*</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>应该会移除所有以 A 为开头的文件而不是只删除文件名是 <code class="java">
A*</code> 的文件。这个特性也是<code class="java">
最小吃惊原则(principle of least surprise)</code></p>
<blockquote>
</blockquote>
<p>  ❝<br>  最小吃惊原则一半常用于用户界面和软件设计。它的原型是：该功能或者特征应该符合用户的预期，不应该使用户感到惊讶和震惊。<br>  ❞</p>
<p>一些有经验的程序员通常希望系统具有较强的功能性和灵活性。设计 Linux 的一个基本目标是每个应用程序只做一件事情并把他做好。所以编译器只负责编译的工作，编译器不会产生列表，因为有其他应用比编译器做的更好。</p>
<p>很多人都不喜欢冗余，为什么在 cp 就能描述清楚你想干什么时候还使用 copy？这完全是在浪费宝贵的 <code class="java">
hacking time</code>。为了从文件中提取所有包含字符串 <code class="java">
ard</code> 的行，Linux 程序员应该输入</p>
<pre class="line-numbers language-java"><code class="language-java">
grep ard f
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="Linux-接口"><a href="#Linux-接口" class="headerlink" title="Linux 接口"></a>Linux 接口</h3><p>Linux 系统是一种金字塔模型的系统，如下所示</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlE2OVFxMWpzMWJ2eVkxaHBrYjhqeUFsOWN3VGQxM1ZVVWljbHlYT2N4Q2o5SkNFZFJMV09xOFRRLzY0MA?x-oss-process=image/format,png">

<p>应用程序发起系统调用把参数放在寄存器中(有时候放在栈中)，并发出 <code class="java">
trap</code> 系统陷入指令切换用户态至内核态。因为不能直接在 C 中编写 trap 指令，因此 C 提供了一个库，库中的函数对应着系统调用。有些函数是使用汇编编写的，但是能够从 C 中调用。每个函数首先把参数放在合适的位置然后执行系统调用指令。因此如果你想要执行 read 系统调用的话，C 程序会调用 read 函数库来执行。这里顺便提一下，是由 POSIX 指定的库接口而不是系统调用接口。也就是说，POSIX 会告诉一个标准系统应该提供哪些库过程，它们的参数是什么，它们必须做什么以及它们必须返回什么结果。</p>
<p>除了操作系统和系统调用库外，Linux 操作系统还要提供一些标准程序，比如文本编辑器、编译器、文件操作工具等。直接和用户打交道的是上面这些应用程序。因此我们可以说 Linux 具有三种不同的接口：<strong>「系统调用接口、库函数接口和应用程序接口」</strong></p>
<p>Linux 中的 <code class="java">
GUI(Graphical User Interface)</code> 和 UNIX 中的非常相似，这种 GUI 创建一个桌面环境，包括窗口、目标和文件夹、工具栏和文件拖拽功能。一个完整的 GUI 还包括窗口管理器以及各种应用程序。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFaWEJ1cmxMMlVQUThRMzNvYzZ4R01JSTVtbHhzMGozNWhIMklQd2lhWVRnRTZHeEF5WkRENjBBLzY0MA?x-oss-process=image/format,png">

<p>Linux 上的 GUI 由 X 窗口支持，主要组成部分是 X 服务器、控制键盘、鼠标、显示器等。当在 Linux 上使用图形界面时，用户可以通过鼠标点击运行程序或者打开文件，通过拖拽将文件进行复制等。</p>
<h3 id="Linux-组成部分"><a href="#Linux-组成部分" class="headerlink" title="Linux 组成部分"></a>Linux 组成部分</h3><p>事实上，Linux 操作系统可以由下面这几部分构成</p>
<ul>
<li><code class="java">
引导程序(Bootloader)</code>：引导程序是管理计算机启动过程的软件，对于大多数用户而言，只是弹出一个屏幕，但其实内部操作系统做了很多事情- <code class="java">
内核(Kernel)</code>：内核是操作系统的核心，负责管理 CPU、内存和外围设备等。- <code class="java">
初始化系统(Init System)</code>：这是一个引导用户空间并负责控制守护程序的子系统。一旦从引导加载程序移交了初始引导，它就是用于管理引导过程的初始化系统。- <code class="java">
后台进程(Daemon)</code>：后台进程顾名思义就是在后台运行的程序，比如打印、声音、调度等，它们可以在引导过程中启动，也可以在登录桌面后启动- <code class="java">
图形服务器(Graphical server)</code>：这是在监视器上显示图形的子系统。通常将其称为 X 服务器或 X。- <code class="java">
桌面环境(Desktop environment)</code>：这是用户与之实际交互的部分，有很多桌面环境可供选择，每个桌面环境都包含内置应用程序，比如文件管理器、Web 浏览器、游戏等- <code class="java">
应用程序(Applications)</code>：桌面环境不提供完整的应用程序，就像 Windows 和 macOS 一样，Linux 提供了成千上万个可以轻松找到并安装的高质量软件。<h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3></li>
</ul>
<p>尽管 Linux 应用程序提供了 GUI ，但是大部分程序员仍偏好于使用<code class="java">
命令行(command-line interface)</code>，称为<code class="java">
shell</code>。用户通常在 GUI 中启动一个 shell 窗口然后就在 shell 窗口下进行工作。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFWWUxLak0wTHo3cmVqVEFjRWlhRXllZktIMzZ3eVdrSTF0czRUU0hMOEVGMU9DTndwTElRN2hRLzY0MA?x-oss-process=image/format,png">

<p>shell 命令行使用速度快、功能更强大、而且易于扩展、并且不会带来<code class="java">
肢体重复性劳损(RSI)</code>。</p>
<p>下面会介绍一些最简单的 bash shell。当 shell 启动时，它首先进行初始化，在屏幕上输出一个 <code class="java">
提示符(prompt)</code>，通常是一个百分号或者美元符号，等待用户输入</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFoMUNlak9ZR2RRelhKMnpwSTJrbnRGMGFGaHg5MmM5bFFzMGZYODl1Q1hZZlVxcEIzdmpsOWcvNjQw?x-oss-process=image/format,png">

<p>等用户输入一个命令后，shell 提取其中的第一个词，这里的词指的是被空格或制表符分隔开的一连串字符。假定这个词是将要运行程序的程序名，那么就会搜索这个程序，如果找到了这个程序就会运行它。然后 shell 会将自己挂起直到程序运行完毕，之后再尝试读入下一条指令。shell 也是一个普通的用户程序。它的主要功能就是读取用户的输入和显示计算的输出。shell 命令中可以包含参数，它们作为字符串传递给所调用的程序。比如</p>
<pre class="line-numbers language-java"><code class="language-java">
cp src dest
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>会调用 cp 应用程序并包含两个参数 <code class="java">
src</code> 和 <code class="java">
dest</code>。这个程序会解释第一个参数是一个已经存在的文件名，然后创建一个该文件的副本，名称为 dest。</p>
<p>并不是所有的参数都是文件名，比如下面</p>
<pre class="line-numbers language-java"><code class="language-java">
head <span class="token operator">-</span><span class="token number">20</span> file
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>第一个参数 -20，会告诉 head 应用程序打印文件的前 20 行，而不是默认的 10 行。控制命令操作或者指定可选值的参数称为<code class="java">
标志(flag)</code>，按照惯例标志应该使用 <code class="java">
-</code> 来表示。这个符号是必要的，比如</p>
<pre class="line-numbers language-java"><code class="language-java">
head <span class="token number">20</span> file
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>是一个完全合法的命令，它会告诉 head 程序输出文件名为 20 的文件的前 10 行，然后输出文件名为 file 文件的前 10 行。Linux 操作系统可以接受一个或多个参数。</p>
<p>为了更容易的指定多个文件名，shell 支持 <code class="java">
魔法字符(magic character)</code>，也被称为<code class="java">
通配符(wild cards)</code>。比如，<code class="java">
*</code> 可以匹配一个或者多个可能的字符串</p>
<pre class="line-numbers language-java"><code class="language-java">
ls <span class="token operator">*</span><span class="token punctuation">.</span>c
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>告诉 ls 列举出所有文件名以 <code class="java">
.c</code> 结束的文件。如果同时存在多个文件，则会在后面进行并列。</p>
<p>另一个通配符是问号，负责匹配任意一个字符。一组在中括号中的字符可以表示其中任意一个，因此</p>
<pre class="line-numbers language-java"><code class="language-java">
ls <span class="token punctuation">[</span>abc<span class="token punctuation">]</span><span class="token operator">*</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>会列举出所有以 <code class="java">
a</code>、<code class="java">
b</code> 或者 <code class="java">
c</code> 开头的文件。</p>
<p>shell 应用程序不一定通过终端进行输入和输出。shell 启动时，就会获取 <strong>「标准输入、标准输出、标准错误」</strong>文件进行访问的能力。</p>
<p>标准输出是从键盘输入的，标准输出或者标准错误是输出到显示器的。许多 Linux 程序默认是从标准输入进行输入并从标准输出进行输出。比如</p>
<pre class="line-numbers language-java"><code class="language-java">
sort 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>会调用 sort 程序，会从终端读取数据(直到用户输入 ctrl-d 结束)，根据字母顺序进行排序，然后将结果输出到屏幕上。</p>
<p>通常还可以重定向标准输入和标准输出，重定向标准输入使用 <code class="java">
&amp;lt;</code> 后面跟文件名。标准输出可以通过一个大于号 <code class="java">
&amp;gt;</code> 进行重定向。允许一个命令中重定向标准输入和输出。例如命令</p>
<pre class="line-numbers language-java"><code class="language-java">
sort <span class="token operator">&amp;</span>lt<span class="token punctuation">;</span>in <span class="token operator">&amp;</span>gt<span class="token punctuation">;</span>out
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>会使 sort 从文件 in 中得到输入，并把结果输出到 out 文件中。由于标准错误没有重定向，所以错误信息会直接打印到屏幕上。从标准输入读入，对其进行处理并将其写入到标准输出的程序称为 <code class="java">
过滤器</code>。</p>
<p>考虑下面由三个分开的命令组成的指令</p>
<pre class="line-numbers language-java"><code class="language-java">
sort <span class="token operator">&amp;</span>lt<span class="token punctuation">;</span>in <span class="token operator">&amp;</span>gt<span class="token punctuation">;</span>temp<span class="token punctuation">;</span>head <span class="token operator">-</span><span class="token number">30</span> <span class="token operator">&amp;</span>lt<span class="token punctuation">;</span>temp<span class="token punctuation">;</span>rm temp
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>首先会调用 sort 应用程序，从标准输入 in 中进行读取，并通过标准输出到 temp。当程序运行完毕后，shell 会运行 head ，告诉它打印前 30 行，并在标准输出(默认为终端)上打印。最后，temp 临时文件被删除。<strong>「轻轻的，你走了，你挥一挥衣袖，不带走一片云彩」</strong>。</p>
<p>命令行中的第一个程序通常会产生输出，在上面的例子中，产生的输出都不 temp 文件接收。然而，Linux 还提供了一个简单的命令来做这件事，例如下面</p>
<pre class="line-numbers language-java"><code class="language-java">
sort <span class="token operator">&amp;</span>lt<span class="token punctuation">;</span>in <span class="token operator">|</span> head <span class="token operator">-</span><span class="token number">30</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>上面 <code class="java">
|</code> 称为竖线符号，它的意思是从 sort 应用程序产生的排序输出会直接作为输入显示，无需创建、使用和移除临时文件。由管道符号连接的命令集合称为<code class="java">
管道(pipeline)</code>。例如如下</p>
<pre class="line-numbers language-java"><code class="language-java">
grep cxuan <span class="token operator">*</span><span class="token punctuation">.</span>c <span class="token operator">|</span> sort <span class="token operator">|</span> head <span class="token operator">-</span><span class="token number">30</span> <span class="token operator">|</span> tail <span class="token operator">-</span><span class="token number">5</span> <span class="token operator">&amp;</span>gt<span class="token punctuation">;</span>f00
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>对任意以 <code class="java">
.c</code> 结尾的文件中包含 <code class="java">
cxuan</code> 的行被写到标准输出中，然后进行排序。这些内容中的前 30 行被 head 出来并传给 tail ，它又将最后 5 行传递给 foo。这个例子提供了一个管道将多个命令连接起来。</p>
<p>可以把一系列 shell 命令放在一个文件中，然后将此文件作为输入来运行。shell 会按照顺序对他们进行处理，就像在键盘上键入命令一样。包含 shell 命令的文件被称为 <code class="java">
shell 脚本(shell scripts)</code>。</p>
<blockquote>
</blockquote>
<p>  ❝<br>  推荐一个 shell 命令的学习网站：<a target="_blank" rel="noopener" href="https://www.shellscript.sh/">https://www.shellscript.sh/</a><br>  ❞</p>
<p>shell 脚本其实也是一段程序，shell 脚本中可以对变量进行赋值，也包含循环控制语句比如 <strong>「if、for、while」</strong> 等，shell 的设计目标是让其看起来和 C 相似(There is no doubt that C is father)。由于 shell 也是一个用户程序，所以用户可以选择不同的 shell。</p>
<h3 id="Linux-应用程序"><a href="#Linux-应用程序" class="headerlink" title="Linux 应用程序"></a>Linux 应用程序</h3><p>Linux 的命令行也就是 shell，它由大量标准应用程序组成。这些应用程序主要有下面六种</p>
<ul>
<li>文件和目录操作命令- 过滤器- 文本程序- 系统管理- 程序开发工具，例如编辑器和编译器- 其他<br>除了这些标准应用程序外，还有其他应用程序比如 <strong>「Web 浏览器、多媒体播放器、图片浏览器、办公软件和游戏程序等」</strong>。</li>
</ul>
<p>我们在上面的例子中已经见过了几个 Linux 的应用程序，比如 sort、cp、ls、head，下面我们再来认识一下其他 Linux 的应用程序。</p>
<p>我们先从几个例子开始讲起，比如</p>
<pre class="line-numbers language-java"><code class="language-java">
cp a b
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>是将 a 复制一个副本为 b ，而</p>
<pre class="line-numbers language-java"><code class="language-java">
mv a b
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>是将 a 移动到 b ，但是删除原文件。</p>
<p>上面这两个命令有一些区别，<code class="java">
cp</code> 是将文件进行复制，复制完成后会有两个文件 a 和 b；而 <code class="java">
mv</code> 相当于是文件的移动，移动完成后就不再有 a 文件。<code class="java">
cat</code> 命令可以把多个文件内容进行连接。使用 <code class="java">
rm</code> 可以删除文件；使用 <code class="java">
chmod</code> 可以允许所有者改变访问权限；文件目录的的创建和删除可以使用 <code class="java">
mkdir</code> 和 <code class="java">
rmdir</code> 命令；使用 <code class="java">
ls</code> 可以查看目录文件，ls 可以显示很多属性，比如大小、用户、创建日期等；sort 决定文件的显示顺序</p>
<p>Linux 应用程序还包括过滤器 grep，<code class="java">
grep</code> 从标准输入或者一个或多个输入文件中提取特定模式的行；<code class="java">
sort</code> 将输入进行排序并输出到标准输出；<code class="java">
head</code> 提取输入的前几行；tail 提取输入的后面几行；除此之外的过滤器还有 <code class="java">
cut</code> 和 <code class="java">
paste</code>，允许对文本行的剪切和复制；<code class="java">
od</code> 将输入转换为 ASCII ；<code class="java">
tr</code> 实现字符大小写转换；<code class="java">
pr</code> 为格式化打印输出等。</p>
<p>程序编译工具使用 <code class="java">
gcc</code>；</p>
<p><code class="java">
make</code> 命令用于自动编译，这是一个很强大的命令，它用于维护一个大的程序，往往这类程序的源码由许多文件构成。典型的，有一些是 <code class="java">
header files 头文件</code>，源文件通常使用 <code class="java">
include</code> 指令包含这些文件，make 的作用就是跟踪哪些文件属于头文件，然后安排自动编译的过程。</p>
<p>下面列出了 POSIX 的标准应用程序</p>
<th width="229">程序</th><th width="266">应用</th>
|------
<td width="144">ls</td><td width="266">列出目录</td>
<td width="144">cp</td><td width="266">复制文件</td>
<td width="144">head</td><td width="266">显示文件的前几行</td>
<td width="144">make</td><td width="266">编译文件生成二进制文件</td>
<td width="144">cd</td><td width="266">切换目录</td>
<td width="144">mkdir</td><td width="266">创建目录</td>
<td width="144">chmod</td><td width="266">修改文件访问权限</td>
<td width="144">ps</td><td width="266">列出文件进程</td>
<td width="144">pr</td><td width="266">格式化打印</td>
<td width="144">rm</td><td width="266">删除一个文件</td>
<td width="144">rmdir</td><td width="266">删除文件目录</td>
<td width="144">tail</td><td width="266">提取文件最后几行</td>
<td width="144">tr</td><td width="266">字符集转换</td>
<td width="144">grep</td><td width="266">分组</td>
<td width="144">cat</td><td width="266">将多个文件连续标准输出</td>
<td width="144">od</td><td width="266">以八进制显示文件</td>
<td width="144">cut</td><td width="266">从文件中剪切</td>
<td width="144">paste</td><td width="266">从文件中粘贴</td>



<h3 id="Linux-内核结构"><a href="#Linux-内核结构" class="headerlink" title="Linux 内核结构"></a>Linux 内核结构</h3><p>在上面我们看到了 Linux 的整体结构，下面我们从整体的角度来看一下 Linux 的内核结构</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFIUWlhWVhnTW5Zbk5Sek5QbHd1Qzk3ejFtQlMyRXVvemg4QmtOMGpUVmljRHE3b1d4WUU2SlZLQS82NDA?x-oss-process=image/format,png">

<p>内核直接坐落在硬件上，内核的主要作用就是 I&#x2F;O 交互、内存管理和控制 CPU 访问。上图中还包括了 <code class="java">
中断</code> 和 <code class="java">
调度器</code>，中断是与设备交互的主要方式。中断出现时调度器就会发挥作用。这里的低级代码停止正在运行的进程，将其状态保存在内核进程结构中，并启动驱动程序。进程调度也会发生在内核完成一些操作并且启动用户进程的时候。图中的调度器是 dispatcher。</p>
<blockquote>
</blockquote>
<p>  ❝<br>  注意这里的调度器是 <code class="java">
dispatcher</code> 而不是 <code class="java">
scheduler</code>，这两者是有区别的<br>  scheduler 和 dispatcher 都是和进程调度相关的概念，不同的是 scheduler 会从几个进程中随意选取一个进程；而 dispatcher 会给 scheduler 选择的进程分配 CPU。<br>  ❞</p>
<p>然后，我们把内核系统分为三部分。</p>
<ul>
<li>I&#x2F;O 部分负责与设备进行交互以及执行网络和存储 I&#x2F;O 操作的所有内核部分。<br>从图中可以看出 I&#x2F;O 层次的关系，最高层是一个<code class="java">
虚拟文件系统</code>，也就是说不管文件是来自内存还是磁盘中，都是经过虚拟文件系统中的。从底层看，所有的驱动都是字符驱动或者块设备驱动。二者的主要区别就是是否允许随机访问。网络驱动设备并不是一种独立的驱动设备，它实际上是一种字符设备，不过网络设备的处理方式和字符设备不同。</li>
</ul>
<p>上面的设备驱动程序中，每个设备类型的内核代码都不同。字符设备有两种使用方式，有<code class="java">
一键式</code>的比如 vi 或者 emacs ，需要每一个键盘输入。其他的比如 shell ，是需要输入一行按回车键将字符串发送给程序进行编辑。</p>
<p>网络软件通常是模块化的，由不同的设备和协议来支持。大多数 Linux 系统在内核中包含一个完整的硬件路由器的功能，但是这个不能和外部路由器相比，路由器上面是<code class="java">
协议栈</code>，包括 TCP&#x2F;IP 协议，协议栈上面是 socket 接口，socket 负责与外部进行通信，充当了门的作用。</p>
<p>磁盘驱动上面是 I&#x2F;O 调度器，它负责排序和分配磁盘读写操作，以尽可能减少磁头的无用移动。</p>
<ul>
<li>I&#x2F;O 右边的是内存部件，程序被装载进内存，由 CPU 执行，这里会涉及到虚拟内存的部件，页面的换入和换出是如何进行的，坏页面的替换和经常使用的页面会进行缓存。- 进程模块负责进程的创建和终止、进程的调度、Linux 把进程和线程看作是可运行的实体，并使用统一的调度策略来进行调度。<br>在内核最顶层的是系统调用接口，所有的系统调用都是经过这里，系统调用会触发一个 trap，将系统从用户态转换为内核态，然后将控制权移交给上面的内核部件。</li>
</ul>
<h2 id="Linux-进程和线程"><a href="#Linux-进程和线程" class="headerlink" title="Linux 进程和线程"></a>Linux 进程和线程</h2><p>下面我们就深入理解一下 Linux 内核来理解 Linux 的基本概念之进程和线程。系统调用是操作系统本身的接口，它对于创建进程和线程，内存分配，共享文件和 I&#x2F;O 来说都很重要。</p>
<p>我们将从各个版本的共性出发来进行探讨。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>每个进程都会运行一段独立的程序，并且在初始化的时候拥有一个独立的控制线程。换句话说，每个进程都会有一个自己的程序计数器，这个程序计数器用来记录下一个需要被执行的指令。Linux 允许进程在运行时创建额外的线程。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFnaWJ6UWV4dVdOb1lUR3VyeGpxdDNuYXZLZDM4emdqaDFqMThIQWxpYjlHUHNrOXliMnMydFBtUS82NDA?x-oss-process=image/format,png">

<p>Linux 是一个多道程序设计系统，因此系统中存在彼此相互独立的进程同时运行。此外，每个用户都会同时有几个活动的进程。因为如果是一个大型系统，可能有数百上千的进程在同时运行。</p>
<p>在某些用户空间中，即使用户退出登录，仍然会有一些后台进程在运行，这些进程被称为 <code class="java">
守护进程(daemon)</code>。</p>
<p>Linux 中有一种特殊的守护进程被称为 <code class="java">
计划守护进程(Cron daemon)</code> ，计划守护进程可以每分钟醒来一次检查是否有工作要做，做完会继续回到睡眠状态等待下一次唤醒。</p>
<blockquote>
</blockquote>
<p>  ❝<br>  Cron 是一个守护程序，可以做任何你想做的事情，比如说你可以定期进行系统维护、定期进行系统备份等。在其他操作系统上也有类似的程序，比如 Mac OS X 上 Cron 守护程序被称为 <code class="java">
launchd</code> 的守护进程。在 Windows 上可以被称为 <code class="java">
计划任务(Task Scheduler)</code>。<br>  ❞</p>
<p>在 Linux 系统中，进程通过非常简单的方式来创建，<code class="java">
fork</code> 系统调用会创建一个源进程的<code class="java">
拷贝(副本)</code>。调用 fork 函数的进程被称为 <code class="java">
父进程(parent process)</code>，使用 fork 函数创建出来的进程被称为 <code class="java">
子进程(child process)</code>。父进程和子进程都有自己的内存映像。如果在子进程创建出来后，父进程修改了一些变量等，那么子进程是看不到这些变化的，也就是 fork 后，父进程和子进程相互独立。</p>
<p>虽然父进程和子进程保持相互独立，但是它们却能够共享相同的文件，如果在 fork 之前，父进程已经打开了某个文件，那么 fork 后，父进程和子进程仍然共享这个打开的文件。对共享文件的修改会对父进程和子进程同时可见。</p>
<p>那么该如何区分父进程和子进程呢？子进程只是父进程的拷贝，所以它们几乎所有的情况都一样，包括内存映像、变量、寄存器等。区分的关键在于 <code class="java">
fork</code> 函数调用后的返回值，如果 fork 后返回一个非零值，这个非零值即是子进程的 <code class="java">
进程标识符(Process Identiier, PID)</code>，而会给子进程返回一个零值，可以用下面代码来进行表示</p>
<pre class="line-numbers language-java"><code class="language-java">
pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用 fork 函数创建进程</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">&amp;</span>lt<span class="token punctuation">;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// pid &amp;lt; 0,创建失败</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">parent_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 父进程代码</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token function">child_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 子进程代码</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>父进程在 fork 后会得到子进程的 PID，这个 PID 即能代表这个子进程的唯一标识符也就是 PID。如果子进程想要知道自己的 PID，可以调用 <code class="java">
getpid</code> 方法。当子进程结束运行时，父进程会得到子进程的 PID，因为一个进程会 fork 很多子进程，子进程也会 fork 子进程，所以 PID 是非常重要的。我们把第一次调用 fork 后的进程称为 <code class="java">
原始进程</code>，一个原始进程可以生成一颗继承树</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFEUVNFZm5JZmFITFVLNG5TaEVsVlFQbDR6WGlhMjB5UE1jblBYWnp3cmM2NVlDRG1xcmJ5WnpnLzY0MA?x-oss-process=image/format,png">

<h3 id="Linux-进程间通信"><a href="#Linux-进程间通信" class="headerlink" title="Linux 进程间通信"></a>Linux 进程间通信</h3><p>Linux 进程间的通信机制通常被称为 <code class="java">
Internel-Process communication,IPC</code>下面我们来说一说 Linux 进程间通信的机制，大致来说，Linux 进程间的通信机制可以分为 6 种</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFOOWt1MUlUZ2RreWt0MmZtVDgxcTRxa3Y2Nm9KRTRqejVacGV5TTlQZ0JUaWNsamRlbWVSaWJwZy82NDA?x-oss-process=image/format,png">

<p>下面我们分别对其进行概述</p>
<h4 id="信号-signal"><a href="#信号-signal" class="headerlink" title="信号 signal"></a>信号 signal</h4><p>信号是 UNIX 系统最先开始使用的进程间通信机制，因为 Linux 是继承于 UNIX 的，所以 Linux 也支持信号机制，通过向一个或多个进程发送<code class="java">
异步事件信号</code>来实现，信号可以从键盘或者访问不存在的位置等地方产生；信号通过 shell 将任务发送给子进程。</p>
<p>你可以在 Linux 系统上输入 <code class="java">
kill -l</code> 来列出系统使用的信号，下面是我提供的一些信号</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFkUlNleWlhT3ZYeFlBdWJNTDJETWhFbG96NExZSmJtTkF1aWNxanBncVJWZEtWWmlhajlwbEtXVncvNjQw?x-oss-process=image/format,png">

<p>进程可以选择忽略发送过来的信号，但是有两个是不能忽略的：<code class="java">
SIGSTOP</code> 和 <code class="java">
SIGKILL</code> 信号。SIGSTOP 信号会通知当前正在运行的进程执行关闭操作，SIGKILL 信号会通知当前进程应该被杀死。除此之外，进程可以选择它想要处理的信号，进程也可以选择阻止信号，如果不阻止，可以选择自行处理，也可以选择进行内核处理。如果选择交给内核进行处理，那么就执行默认处理。</p>
<p>操作系统会中断目标程序的进程来向其发送信号、在任何非原子指令中，执行都可以中断，如果进程已经注册了新号处理程序，那么就执行进程，如果没有注册，将采用默认处理的方式。</p>
<p>例如：当进程收到 <code class="java">
SIGFPE</code> 浮点异常的信号后，默认操作是对其进行 <code class="java">
dump(转储)</code>和退出。信号没有优先级的说法。如果同时为某个进程产生了两个信号，则可以将它们呈现给进程或者以任意的顺序进行处理。</p>
<p>下面我们就来看一下这些信号是干什么用的</p>
<ul>
<li>SIGABRT 和 SIGIOT<br>SIGABRT 和 SIGIOT 信号发送给进程，告诉其进行终止，这个 信号通常在调用 C标准库的<code class="java">
abort()</code>函数时由进程本身启动</li>
<li>SIGALRM 、 SIGVTALRM、SIGPROF<br>当设置的时钟功能超时时会将 SIGALRM 、 SIGVTALRM、SIGPROF 发送给进程。当实际时间或时钟时间超时时，发送 SIGALRM。当进程使用的 CPU 时间超时时，将发送 SIGVTALRM。当进程和系统代表进程使用的CPU 时间超时时，将发送 SIGPROF。</li>
<li>SIGBUS<br>SIGBUS 将造成<code class="java">
总线中断</code>错误时发送给进程</li>
<li>SIGCHLD<br>当子进程终止、被中断或者被中断恢复，将 SIGCHLD 发送给进程。此信号的一种常见用法是指示操作系统在子进程终止后清除其使用的资源。</li>
<li>SIGCONT<br>SIGCONT 信号指示操作系统继续执行先前由 SIGSTOP 或 SIGTSTP 信号暂停的进程。该信号的一个重要用途是在 Unix shell 中的作业控制中。</li>
<li>SIGFPE<br>SIGFPE 信号在执行错误的算术运算（例如除以零）时将被发送到进程。</li>
<li>SIGUP<br>当 SIGUP 信号控制的终端关闭时，会发送给进程。许多守护程序将重新加载其配置文件并重新打开其日志文件，而不是在收到此信号时退出。</li>
<li>SIGILL<br>SIGILL 信号在尝试执行非法、格式错误、未知或者特权指令时发出</li>
<li>SIGINT<br>当用户希望中断进程时，操作系统会向进程发送 SIGINT 信号。用户输入 ctrl - c 就是希望中断进程。</li>
<li>SIGKILL<br>SIGKILL 信号发送到进程以使其马上进行终止。与 SIGTERM 和 SIGINT 相比，这个信号无法捕获和忽略执行，并且进程在接收到此信号后无法执行任何清理操作，下面是一些例外情况</li>
</ul>
<p>僵尸进程无法杀死，因为僵尸进程已经死了，它在等待父进程对其进行捕获</p>
<p>处于阻塞状态的进程只有再次唤醒后才会被 kill 掉</p>
<p><code class="java">
init</code> 进程是 Linux 的初始化进程，这个进程会忽略任何信号。</p>
<p>SIGKILL 通常是作为最后杀死进程的信号、它通常作用于 SIGTERM 没有响应时发送给进程。</p>
<ul>
<li>SIGPIPE<br>SIGPIPE 尝试写入进程管道时发现管道未连接无法写入时发送到进程</li>
<li>SIGPOLL<br>当在明确监视的文件描述符上发生事件时，将发送 SIGPOLL 信号。</li>
<li>SIGRTMIN 至 SIGRTMAX<br>SIGRTMIN 至 SIGRTMAX 是<code class="java">
实时信号</code></li>
<li>SIGQUIT<br>当用户请求退出进程并执行核心转储时，SIGQUIT 信号将由其控制终端发送给进程。</li>
<li>SIGSEGV<br>当 SIGSEGV 信号做出无效的虚拟内存引用或分段错误时，即在执行分段违规时，将其发送到进程。</li>
<li>SIGSTOP<br>SIGSTOP 指示操作系统终止以便以后进行恢复时</li>
<li>SIGSYS<br>当 SIGSYS 信号将错误参数传递给系统调用时，该信号将发送到进程。</li>
<li>SYSTERM<br>我们上面简单提到过了 SYSTERM 这个名词，这个信号发送给进程以请求终止。与 SIGKILL 信号不同，该信号可以被过程捕获或忽略。这允许进程执行良好的终止，从而释放资源并在适当时保存状态。SIGINT 与SIGTERM 几乎相同。</li>
<li>SIGTSIP<br>SIGTSTP 信号由其控制终端发送到进程，以请求终端停止。</li>
<li>SIGTTIN 和 SIGTTOU<br>当 SIGTTIN 和SIGTTOU 信号分别在后台尝试从 tty 读取或写入时，信号将发送到该进程。</li>
<li>SIGTRAP<br>在发生异常或者 trap 时，将 SIGTRAP 信号发送到进程</li>
<li>SIGURG<br>当套接字具有可读取的紧急或带外数据时，将 SIGURG 信号发送到进程。</li>
<li>SIGUSR1 和 SIGUSR2<br>SIGUSR1 和 SIGUSR2 信号被发送到进程以指示用户定义的条件。</li>
<li>SIGXCPU<br>当 SIGXCPU 信号耗尽 CPU 的时间超过某个用户可设置的预定值时，将其发送到进程</li>
<li>SIGXFSZ<br>当 SIGXFSZ 信号增长超过最大允许大小的文件时，该信号将发送到该进程。</li>
<li>SIGWINCH<br>SIGWINCH 信号在其控制终端更改其大小（窗口更改）时发送给进程。</li>
</ul>
<h4 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道 pipe"></a>管道 pipe</h4><p>Linux 系统中的进程可以通过建立管道 pipe 进行通信。</p>
<p>在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。管道是同步的，当进程尝试从空管道读取数据时，该进程会被阻塞，直到有可用数据为止。shell 中的<code class="java">
管线 pipelines</code> 就是用管道实现的，当 shell 发现输出</p>
<pre class="line-numbers language-java"><code class="language-java">
sort <span class="token operator">&amp;</span>lt<span class="token punctuation">;</span>f <span class="token operator">|</span> head
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>它会创建两个进程，一个是 sort，一个是 head，sort，会在这两个应用程序之间建立一个管道使得 sort 进程的标准输出作为 head 程序的标准输入。sort 进程产生的输出就不用写到文件中了，如果管道满了系统会停止 sort 以等待 head 读出数据</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFpYTRzSlJ5dmliaWM3UzAyTG1EU2ZXcjZkM3EwNlZSM2RlVkJ1N3Rua1ROZXB1T2RTWEwyMDN3RUEvNjQw?x-oss-process=image/format,png">

<p>管道实际上就是 <code class="java">
|</code>，两个应用程序不知道有管道的存在，一切都是由 shell 管理和控制的。</p>
<h4 id="共享内存-shared-memory"><a href="#共享内存-shared-memory" class="headerlink" title="共享内存 shared memory"></a>共享内存 shared memory</h4><p>两个进程之间还可以通过共享内存进行进程间通信，其中两个或者多个进程可以访问公共内存空间。两个进程的共享工作是通过共享内存完成的，一个进程所作的修改可以对另一个进程可见(很像线程间的通信)。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFFNkVLbDZWNmZBSlNBNTRMNlVmaWMyMVRybGljMVV4WGVER0dYYTRHaWNubVM0bGljQ3ZGYXBpYVBEdy82NDA?x-oss-process=image/format,png">

<p>在使用共享内存前，需要经过一系列的调用流程，流程如下</p>
<ul>
<li>创建共享内存段或者使用已创建的共享内存段<code class="java">
(shmget())</code>- 将进程附加到已经创建的内存段中<code class="java">
(shmat())</code>- 从已连接的共享内存段分离进程<code class="java">
(shmdt())</code>- 对共享内存段执行控制操作<code class="java">
(shmctl())</code><h4 id="先入先出队列-FIFO"><a href="#先入先出队列-FIFO" class="headerlink" title="先入先出队列 FIFO"></a>先入先出队列 FIFO</h4></li>
</ul>
<p>先入先出队列 FIFO 通常被称为 <code class="java">
命名管道(Named Pipes)</code>，命名管道的工作方式与常规管道非常相似，但是确实有一些明显的区别。未命名的管道没有备份文件：操作系统负责维护内存中的缓冲区，用来将字节从写入器传输到读取器。一旦写入或者输出终止的话，缓冲区将被回收，传输的数据会丢失。相比之下，命名管道具有支持文件和独特 API ，命名管道在文件系统中作为设备的专用文件存在。当所有的进程通信完成后，命名管道将保留在文件系统中以备后用。命名管道具有严格的 FIFO 行为</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFpYlViNFhqaWE2RUNVZTUwTzdyUm91Q0RDaWJoM3l0Um1YWmppYXB6NWljTEhUb2dZcG9ZeWhPck9NQS82NDA?x-oss-process=image/format,png">

<p>写入的第一个字节是读取的第一个字节，写入的第二个字节是读取的第二个字节，依此类推。</p>
<h4 id="消息队列-Message-Queue"><a href="#消息队列-Message-Queue" class="headerlink" title="消息队列 Message Queue"></a>消息队列 Message Queue</h4><p>一听到消息队列这个名词你可能不知道是什么意思，消息队列是用来描述内核寻址空间内的内部链接列表。可以按几种不同的方式将消息按顺序发送到队列并从队列中检索消息。每个消息队列由 IPC 标识符唯一标识。消息队列有两种模式，一种是<code class="java">
严格模式</code>， 严格模式就像是 FIFO 先入先出队列似的，消息顺序发送，顺序读取。还有一种模式是 <code class="java">
非严格模式</code>，消息的顺序性不是非常重要。</p>
<h4 id="套接字-Socket"><a href="#套接字-Socket" class="headerlink" title="套接字 Socket"></a>套接字 Socket</h4><p>还有一种管理两个进程间通信的是使用 <code class="java">
socket</code>，socket 提供端到端的双相通信。一个套接字可以与一个或多个进程关联。就像管道有命令管道和未命名管道一样，套接字也有两种模式，套接字一般用于两个进程之间的网络通信，网络套接字需要来自诸如<code class="java">
TCP（传输控制协议）</code>或较低级别<code class="java">
UDP（用户数据报协议）</code>等基础协议的支持。</p>
<p>套接字有以下几种分类</p>
<ul>
<li><code class="java">
顺序包套接字(Sequential Packet Socket)</code>：此类套接字为最大长度固定的数据报提供可靠的连接。此连接是双向的并且是顺序的。- <code class="java">
数据报套接字(Datagram Socket)</code>：数据包套接字支持双向数据流。数据包套接字接受消息的顺序与发送者可能不同。- <code class="java">
流式套接字(Stream Socket)</code>：流套接字的工作方式类似于电话对话，提供双向可靠的数据流。- <code class="java">
原始套接字(Raw Socket)</code>：可以使用原始套接字访问基础通信协议。<h3 id="Linux-中进程管理系统调用"><a href="#Linux-中进程管理系统调用" class="headerlink" title="Linux 中进程管理系统调用"></a>Linux 中进程管理系统调用</h3></li>
</ul>
<p>现在关注一下 Linux 系统中与进程管理相关的系统调用。在了解之前你需要先知道一下什么是系统调用。</p>
<p>操作系统为我们屏蔽了硬件和软件的差异，它的最主要功能就是为用户提供一种抽象，隐藏内部实现，让用户只关心在 GUI 图形界面下如何使用即可。操作系统可以分为两种模式</p>
<ul>
<li>内核态：操作系统内核使用的模式- 用户态：用户应用程序所使用的模式<br>我们常说的<code class="java">
上下文切换</code> 指的就是内核态模式和用户态模式的频繁切换。而<code class="java">
系统调用</code>指的就是引起内核态和用户态切换的一种方式，系统调用通常在后台静默运行，表示计算机程序向其操作系统内核请求服务。</li>
</ul>
<p>系统调用指令有很多，下面是一些与进程管理相关的最主要的系统调用</p>
<h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p>fork 调用用于创建一个与父进程相同的子进程，创建完进程后的子进程拥有和父进程一样的程序计数器、相同的 CPU 寄存器、相同的打开文件。</p>
<h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p>exec 系统调用用于执行驻留在活动进程中的文件，调用 exec 后，新的可执行文件会替换先前的可执行文件并获得执行。也就是说，调用 exec 后，会将旧文件或程序替换为新文件或执行，然后执行文件或程序。新的执行程序被加载到相同的执行空间中，因此进程的 <code class="java">
PID</code>不会修改，因为我们<strong>「没有创建新进程，只是替换旧进程」</strong>。但是进程的数据、代码、堆栈都已经被修改。如果当前要被替换的进程包含多个线程，那么所有的线程将被终止，新的进程映像被加载执行。</p>
<p>这里需要解释一下<code class="java">
进程映像(Process image)</code> 的概念</p>
<p><strong>「什么是进程映像呢」</strong>？进程映像是执行程序时所需要的可执行文件，通常会包括下面这些东西</p>
<ul>
<li><strong>「代码段（codesegment&#x2F;textsegment）」</strong><br>又称文本段，用来存放指令，运行代码的一块内存空间</li>
</ul>
<p>此空间大小在代码运行前就已经确定</p>
<p>内存空间一般属于只读，某些架构的代码也允许可写</p>
<p>在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</p>
<ul>
<li><strong>「数据段（datasegment）」</strong><br>可读可写</li>
</ul>
<p>存储初始化的全局变量和初始化的 static 变量</p>
<p>数据段中数据的生存期是随程序持续性（随进程持续性） 随进程持续性：进程创建就存在，进程死亡就消失</p>
<ul>
<li><strong>「bss 段（bsssegment）：」</strong><br>可读可写</li>
</ul>
<p>存储未初始化的全局变量和未初始化的 static 变量</p>
<p>bss 段中的数据一般默认为 0</p>
<ul>
<li><strong>「Data 段」</strong><br>是可读写的，因为变量的值可以在运行时更改。此段的大小也固定。</li>
<li><strong>「栈（stack）：」</strong><br>可读可写</li>
</ul>
<p>存储的是函数或代码中的局部变量(非 static 变量)</p>
<p>栈的生存期随代码块持续性，代码块运行就给你分配空间，代码块结束，就自动回收空间</p>
<ul>
<li><strong>「堆（heap）：」</strong><br>可读可写</li>
</ul>
<p>存储的是程序运行期间动态分配的 malloc&#x2F;realloc 的空间</p>
<p>堆的生存期随进程持续性，从 malloc&#x2F;realloc 到 free 一直存在</p>
<p>下面是这些区域的构成图</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFyZHpNeWNXZ3NSMXpIQ1BZcnphblVVOVdjN2xpYnhtZ2NkSjQyS1dYdXFVanRpYWVwcmlib3ZxUmcvNjQw?x-oss-process=image/format,png">

<p>exec 系统调用是一些函数的集合，这些函数是</p>
<ul>
<li>execl- execle- execlp- execv- execve- execvp<br>下面来看一下 exec 的工作原理</li>
</ul>
<ol>
<li>当前进程映像被替换为新的进程映像1. 新的进程映像是你做为 exec 传递的灿睡1. 结束当前正在运行的进程1. 新的进程映像有 PID，相同的环境和一些文件描述符(因为未替换进程，只是替换了进程映像)1. CPU 状态和虚拟内存受到影响，当前进程映像的虚拟内存映射被新进程映像的虚拟内存代替。<h4 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h4></li>
</ol>
<p>等待子进程结束或终止</p>
<h4 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h4><p>在许多计算机操作系统上，计算机进程的终止是通过执行 <code class="java">
exit</code> 系统调用命令执行的。0 表示进程能够正常结束，其他值表示进程以非正常的行为结束。</p>
<p>其他一些常见的系统调用如下</p>
<th width="242">系统调用指令</th><th width="273">描述</th>
|------
<td width="139">pause</td><td width="273">挂起信号</td>
<td width="139">nice</td><td width="273">改变分时进程的优先级</td>
<td width="139">ptrace</td><td width="273">进程跟踪</td>
<td width="139">kill</td><td width="273">向进程发送信号</td>
<td width="139">pipe</td><td width="273">创建管道</td>
<td width="139">mkfifo</td><td width="273">创建 fifo 的特殊文件（命名管道）</td>
<td width="139">sigaction</td><td width="273">设置对指定信号的处理方法</td>
<td width="139">msgctl</td><td width="273">消息控制操作</td>
<td width="139">semctl</td><td width="273">信号量控制</td>



<h3 id="Linux-进程和线程的实现"><a href="#Linux-进程和线程的实现" class="headerlink" title="Linux 进程和线程的实现"></a>Linux 进程和线程的实现</h3><h4 id="Linux-进程"><a href="#Linux-进程" class="headerlink" title="Linux 进程"></a>Linux 进程</h4><p>在 Linux 内核结构中，进程会被表示为 <code class="java">
任务</code>，通过结构体 <code class="java">
structure</code> 来创建。不像其他的操作系统会区分进程、轻量级进程和线程，Linux 统一使用任务结构来代表执行上下文。因此，对于每个单线程进程来说，单线程进程将用一个任务结构表示，对于多线程进程来说，将为每一个用户级线程分配一个任务结构。Linux 内核是多线程的，并且内核级线程不与任何用户级线程相关联。</p>
<p>对于每个进程来说，在内存中都会有一个 <code class="java">
task_struct</code> 进程描述符与之对应。进程描述符包含了内核管理进程所有有用的信息，包括 <strong>「调度参数、打开文件描述符等等」</strong>。进程描述符从进程创建开始就一直存在于内核堆栈中。</p>
<p>Linux 和 Unix 一样，都是通过 <code class="java">
PID</code> 来区分不同的进程，内核会将所有进程的任务结构组成为一个双向链表。PID 能够直接被映射称为进程的任务结构所在的地址，从而不需要遍历双向链表直接访问。</p>
<p>我们上面提到了进程描述符，这是一个非常重要的概念，我们上面还提到了进程描述符是位于内存中的，这里我们省略了一句话，那就是进程描述符是存在用户的任务结构中，当进程位于内存并开始运行时，进程描述符才会被调入内存。</p>
<blockquote>
</blockquote>
<p>  ❝<br>  <code class="java">
进程位于内存</code>被称为 <code class="java">
PIM(Process In Memory)</code> ，这是冯诺伊曼体系架构的一种体现，加载到内存中并执行的程序称为进程。简单来说，一个进程就是正在执行的程序。<br>  ❞</p>
<p>进程描述符可以归为下面这几类</p>
<ul>
<li><code class="java">
调度参数(scheduling parameters)</code>：进程优先级、最近消耗 CPU 的时间、最近睡眠时间一起决定了下一个需要运行的进程- <code class="java">
内存映像(memory image)</code>：我们上面说到，进程映像是执行程序时所需要的可执行文件，它由数据和代码组成。- <code class="java">
信号(signals)</code>：显示哪些信号被捕获、哪些信号被执行- <code class="java">
寄存器</code>：当发生内核陷入 (trap) 时，寄存器的内容会被保存下来。- <code class="java">
系统调用状态(system call state)</code>：当前系统调用的信息，包括参数和结果- <code class="java">
文件描述符表(file descriptor table)</code>：有关文件描述符的系统被调用时，文件描述符作为索引在文件描述符表中定位相关文件的 i-node 数据结构- <code class="java">
统计数据(accounting)</code>：记录用户、进程占用系统 CPU 时间表的指针，一些操作系统还保存进程最多占用的 CPU 时间、进程拥有的最大堆栈空间、进程可以消耗的页面数等。- <code class="java">
内核堆栈(kernel stack)</code>：进程的内核部分可以使用的固定堆栈- <code class="java">
其他</code>：当前进程状态、事件等待时间、距离警报的超时时间、PID、父进程的 PID 以及用户标识符等<br>有了上面这些信息，现在就很容易描述在 Linux 中是如何创建这些进程的了，创建新流程实际上非常简单。<strong>「为子进程开辟一块新的用户空间的进程描述符，然后从父进程复制大量的内容。为这个子进程分配一个 PID，设置其内存映射，赋予它访问父进程文件的权限，注册并启动」</strong>。</li>
</ul>
<p>当执行 fork 系统调用时，调用进程会陷入内核并创建一些和任务相关的数据结构，比如<code class="java">
内核堆栈(kernel stack)</code> 和 <code class="java">
thread_info</code> 结构。</p>
<blockquote>
</blockquote>
<p>  ❝<br>  关于 thread_info 结构可以参考<br>  <a target="_blank" rel="noopener" href="https://docs.huihoo.com/doxygen/linux/kernel/3.7/arch_2avr32_2include_2asm_2thread__info_8h_source.html">https://docs.huihoo.com/doxygen/linux/kernel/3.7/arch_2avr32_2include_2asm_2thread__info_8h_source.html</a><br>  ❞</p>
<p>这个结构中包含进程描述符，进程描述符位于固定的位置，使得 Linux 系统只需要很小的开销就可以定位到一个运行中进程的数据结构。</p>
<p>进程描述符的主要内容是根据<code class="java">
父进程</code>的描述符来填充。Linux 操作系统会寻找一个可用的 PID，并且此 PID 没有被任何进程使用，更新进程标示符使其指向一个新的数据结构即可。为了减少 hash table 的碰撞，进程描述符会形成<code class="java">
链表</code>。它还将 task_struct 的字段设置为指向任务数组上相应的上一个&#x2F;下一个进程。</p>
<blockquote>
</blockquote>
<p>  ❝<br>  task_struct ：Linux 进程描述符，内部涉及到众多 C++ 源码，我们会在后面进行讲解。<br>  ❞</p>
<p>从原则上来说，为子进程开辟内存区域并为子进程分配数据段、堆栈段，并且对父进程的内容进行复制，但是实际上 fork 完成后，子进程和父进程没有共享内存，所以需要复制技术来实现同步，但是复制开销比较大，因此 Linux 操作系统使用了一种 <code class="java">
欺骗</code> 方式。即为子进程分配页表，然后新分配的页表指向父进程的页面，同时这些页面是只读的。当进程向这些页面进行写入的时候，会开启保护错误。内核发现写入操作后，会为进程分配一个副本，使得写入时把数据复制到这个副本上，这个副本是共享的，这种方式称为 <code class="java">
写入时复制(copy on write)</code>，这种方式避免了在同一块内存区域维护两个副本的必要，节省内存空间。</p>
<p>在子进程开始运行后，操作系统会调用 exec 系统调用，内核会进行查找验证可执行文件，把参数和环境变量复制到内核，释放旧的地址空间。</p>
<p>现在新的地址空间需要被创建和填充。如果系统支持映射文件，就像 Unix 系统一样，那么新的页表就会创建，表明内存中没有任何页，除非所使用的页面是堆栈页，其地址空间由磁盘上的可执行文件支持。新进程开始运行时，立刻会收到一个<code class="java">
缺页异常(page fault)</code>，这会使具有代码的页面加载进入内存。最后，参数和环境变量被复制到新的堆栈中，重置信号，寄存器全部清零。新的命令开始运行。</p>
<p>下面是一个示例，用户输出 ls，shell 会调用 fork 函数复制一个新进程，shell 进程会调用 exec 函数用可执行文件 ls 的内容覆盖它的内存。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlF5MVdHYU1McWc3SDhUVjZKZDZMcXg5RmRHcDFqMEhiUVRwcTNHbXdZaWNXcmlhcHJ1YlVMVVphdy82NDA?x-oss-process=image/format,png">

<h4 id="Linux-线程"><a href="#Linux-线程" class="headerlink" title="Linux 线程"></a>Linux 线程</h4><p>现在我们来讨论一下 Linux 中的线程，线程是轻量级的进程，想必这句话你已经听过很多次了，<code class="java">
轻量级</code>体现在所有的进程切换都需要清除所有的表、进程间的共享信息也比较麻烦，一般来说通过管道或者共享内存，如果是 fork 函数后的父子进程则使用共享文件，然而线程切换不需要像进程一样具有昂贵的开销，而且线程通信起来也更方便。线程分为两种：用户级线程和内核级线程</p>
<h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p>用户级线程避免使用内核，通常，每个线程会显示调用开关，发送信号或者执行某种切换操作来放弃 CPU，同样，计时器可以强制进行开关，用户线程的切换速度通常比内核线程快很多。在用户级别实现线程会有一个问题，即单个线程可能会垄断 CPU 时间片，导致其他线程无法执行从而 <code class="java">
饿死</code>。如果执行一个 I&#x2F;O 操作，那么 I&#x2F;O 会阻塞，其他线程也无法运行。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlE3eFdjbU41Y2thVlJHM0MyY2J4QUhLZzBSUGxVNTlUVmlhOVBVYXRnbVBCM09HazA2UXF2WmdBLzY0MA?x-oss-process=image/format,png">

<p>一种解决方案是，一些用户级的线程包解决了这个问题。可以使用时钟周期的监视器来控制第一时间时间片独占。然后，一些库通过特殊的包装来解决系统调用的 I&#x2F;O 阻塞问题，或者可以为非阻塞 I&#x2F;O 编写任务。</p>
<h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p>内核级线程通常使用几个进程表在内核中实现，每个任务都会对应一个进程表。在这种情况下，内核会在每个进程的时间片内调度每个线程。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFGbGYxMXZDNTdob3VPc3NuQllERkhESm0wcVJNZHlHMld1MEJQNmRLbGU5MmpXaWNKMERUbkxRLzY0MA?x-oss-process=image/format,png">

<p>所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。</p>
<p>从用户空间 -&gt; 内核空间 -&gt; 用户空间的开销比较大，但是线程初始化的时间损耗可以忽略不计。这种实现的好处是由时钟决定线程切换时间，因此不太可能将时间片与任务中的其他线程占用时间绑定到一起。同样，I&#x2F;O 阻塞也不是问题。</p>
<h4 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h4><p>结合用户空间和内核空间的优点，设计人员采用了一种<code class="java">
内核级线程</code>的方式，然后将用户级线程与某些或者全部内核线程多路复用起来</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFpYkFLbWFlMHJIbk5aaWJHSVIyN2pXSUhTa1FtempkNU9INlMyQ01YNmw2RzBXTlZIZmpiZjlCdy82NDA?x-oss-process=image/format,png">

<p>在这种模型中，编程人员可以自由控制用户线程和内核线程的数量，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。</p>
<h3 id="Linux-调度"><a href="#Linux-调度" class="headerlink" title="Linux 调度"></a>Linux 调度</h3><p>下面我们来关注一下 Linux 系统的调度算法，首先需要认识到，Linux 系统的线程是内核线程，所以 Linux 系统是基于线程的，而不是基于进程的。</p>
<p>为了进行调度，Linux 系统将线程分为三类</p>
<ul>
<li>实时先入先出- 实时轮询- 分时<br>实时先入先出线程具有最高优先级，它不会被其他线程所抢占，除非那是一个刚刚准备好的，拥有更高优先级的线程进入。实时轮转线程与实时先入先出线程基本相同，只是每个实时轮转线程都有一个时间量，时间到了之后就可以被抢占。如果多个实时线程准备完毕，那么每个线程运行它时间量所规定的时间，然后插入到实时轮转线程末尾。</li>
</ul>
<blockquote>
</blockquote>
<p>  ❝<br>  注意这个实时只是相对的，无法做到绝对的实时，因为线程的运行时间无法确定。它们相对分时系统来说，更加具有实时性<br>  ❞</p>
<p>Linux 系统会给每个线程分配一个 <code class="java">
nice</code> 值，这个值代表了优先级的概念。nice 值默认值是 0 ，但是可以通过系统调用 nice 值来修改。修改值的范围从 -20 - +19。nice 值决定了线程的静态优先级。一般系统管理员的 nice 值会比一般线程的优先级高，它的范围是 -20 - -1。</p>
<p>下面我们更详细的讨论一下 Linux 系统的两个调度算法，它们的内部与<code class="java">
调度队列(runqueue)</code> 的设计很相似。运行队列有一个数据结构用来监视系统中所有可运行的任务并选择下一个可以运行的任务。每个运行队列和系统中的每个 CPU 有关。</p>
<p><code class="java">
Linux O(1)</code> 调度器是历史上很流行的一个调度器。这个名字的由来是因为它能够在常数时间内执行任务调度。在 O(1) 调度器里，调度队列被组织成两个数组，一个是任务<strong>「正在活动」</strong>的数组，一个是任务<strong>「过期失效」</strong>的数组。如下图所示，每个数组都包含了 140 个链表头，每个链表头具有不同的优先级。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFLRkhHTEQ1WU9GS1BTeEY0dnJGQ21Ic01ubElSYjMxNzA5Y0plTDlyVEpONUlCZmZraDhhTGcvNjQw?x-oss-process=image/format,png">

<p>大致流程如下：</p>
<p>调度器从正在活动数组中选择一个优先级最高的任务。如果这个任务的时间片过期失效了，就把它移动到过期失效数组中。如果这个任务阻塞了，比如说正在等待 I&#x2F;O 事件，那么在它的时间片过期失效之前，一旦 I&#x2F;O 操作完成，那么这个任务将会继续运行，它将被放回到之前正在活动的数组中，因为这个任务之前已经消耗一部分 CPU 时间片，所以它将运行剩下的时间片。当这个任务运行完它的时间片后，它就会被放到过期失效数组中。一旦正在活动的任务数组中没有其他任务后，调度器将会交换指针，使得正在活动的数组变为过期失效数组，过期失效数组变为正在活动的数组。使用这种方式可以保证每个优先级的任务都能够得到执行，不会导致线程饥饿。</p>
<p>在这种调度方式中，不同优先级的任务所得到 CPU 分配的时间片也是不同的，高优先级进程往往能得到较长的时间片，低优先级的任务得到较少的时间片。</p>
<p>这种方式为了保证能够更好的提供服务，通常会为 <code class="java">
交互式进程</code> 赋予较高的优先级，交互式进程就是<code class="java">
用户进程</code>。</p>
<p>Linux 系统不知道一个任务究竟是 I&#x2F;O 密集型的还是 CPU 密集型的，它只是依赖于交互式的方式，Linux 系统会区分是<code class="java">
静态优先级</code> 还是 <code class="java">
动态优先级</code>。动态优先级是采用一种奖励机制来实现的。奖励机制有两种方式：<strong>「奖励交互式线程、惩罚占用 CPU 的线程」</strong>。在 Linux O(1) 调度器中，最高的优先级奖励是 -5，注意这个优先级越低越容易被线程调度器接受，所以最高惩罚的优先级是 +5。具体体现就是操作系统维护一个名为 <code class="java">
sleep_avg</code> 的变量，任务唤醒会增加 sleep_avg 变量的值，当任务被抢占或者时间量过期会减少这个变量的值，反映在奖励机制上。</p>
<blockquote>
</blockquote>
<p>  ❝<br>  O(1) 调度算法是 2.6 内核版本的调度器，最初引入这个调度算法的是不稳定的 2.5 版本。早期的调度算法在多处理器环境中说明了通过访问正在活动数组就可以做出调度的决定。使调度可以在固定的时间 O(1) 完成。<br>  ❞</p>
<p>O(1) 调度器使用了一种 <code class="java">
启发式</code> 的方式，这是什么意思？</p>
<blockquote>
</blockquote>
<p>  ❝<br>  在计算机科学中，启发式是一种当传统方式解决问题很慢时用来快速解决问题的方式，或者找到一个在传统方法无法找到任何精确解的情况下找到近似解。<br>  ❞</p>
<p>O(1) 使用启发式的这种方式，会使任务的优先级变得复杂并且不完善，从而导致在处理交互任务时性能很糟糕。</p>
<p>为了改进这个缺点，O(1) 调度器的开发者又提出了一个新的方案，即 <code class="java">
公平调度器(Completely Fair Scheduler, CFS)</code>。CFS 的主要思想是使用一颗<code class="java">
红黑树</code>作为调度队列。</p>
<blockquote>
</blockquote>
<p>  ❝<br>  数据结构太重要了。<br>  ❞</p>
<p>CFS 会根据任务在 CPU 上的运行时间长短而将其有序地排列在树中，时间精确到纳秒级。下面是 CFS 的构造模型</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlF5MnpVM29uUnBPczMxV0ZKRjlYbk5kcWVrMUxGUkJNeXR1N01iWGVvaWE2dGRuZThCVXZFSVNnLzY0MA?x-oss-process=image/format,png">

<p>CFS 的调度过程如下：</p>
<p>CFS 算法总是优先调度哪些使用 CPU 时间最少的任务。最小的任务一般都是在最左边的位置。当有一个新的任务需要运行时，CFS 会把这个任务和最左边的数值进行对比，如果此任务具有最小时间值，那么它将进行运行，否则它会进行比较，找到合适的位置进行插入。然后 CPU 运行红黑树上当前比较的最左边的任务。</p>
<p>在红黑树中选择一个节点来运行的时间可以是常数时间，但是插入一个任务的时间是 <code class="java">
O(loog(N))</code>，其中 N 是系统中的任务数。考虑到当前系统的负载水平，这是可以接受的。</p>
<p>调度器只需要考虑可运行的任务即可。这些任务被放在适当的调度队列中。不可运行的任务和正在等待的各种 I&#x2F;O 操作或内核事件的任务被放入一个<code class="java">
等待队列</code>中。等待队列头包含一个指向任务链表的指针和一个自旋锁。自旋锁对于并发处理场景下用处很大。</p>
<h4 id="Linux-系统中的同步"><a href="#Linux-系统中的同步" class="headerlink" title="Linux 系统中的同步"></a>Linux 系统中的同步</h4><p>下面来聊一下 Linux 中的同步机制。早期的 Linux 内核只有一个 <code class="java">
大内核锁(Big Kernel Lock,BKL)</code> 。它阻止了不同处理器并发处理的能力。因此，需要引入一些粒度更细的锁机制。</p>
<p>Linux 提供了若干不同类型的同步变量，这些变量既能够在内核中使用，也能够在用户应用程序中使用。在地层中，Linux 通过使用 <code class="java">
atomic_set</code> 和 <code class="java">
atomic_read</code> 这样的操作为硬件支持的原子指令提供封装。硬件提供内存重排序，这是 Linux 屏障的机制。</p>
<p>具有高级别的同步像是自旋锁的描述是这样的，当两个进程同时对资源进行访问，在一个进程获得资源后，另一个进程不想被阻塞，所以它就会自旋，等待一会儿再对资源进行访问。Linux 也提供互斥量或信号量这样的机制，也支持像是 <code class="java">
mutex_tryLock</code> 和 <code class="java">
mutex_tryWait</code> 这样的非阻塞调用。也支持中断处理事务，也可以通过动态禁用和启用相应的中断来实现。</p>
<h3 id="Linux-启动"><a href="#Linux-启动" class="headerlink" title="Linux 启动"></a>Linux 启动</h3><p>下面来聊一聊 Linux 是如何启动的。</p>
<p>当计算机电源通电后，<code class="java">
BIOS</code>会进行<code class="java">
开机自检(Power-On-Self-Test, POST)</code>，对硬件进行检测和初始化。因为操作系统的启动会使用到磁盘、屏幕、键盘、鼠标等设备。下一步，磁盘中的第一个分区，也被称为 <code class="java">
MBR(Master Boot Record)</code> 主引导记录，被读入到一个固定的内存区域并执行。这个分区中有一个非常小的，只有 512 字节的程序。程序从磁盘中调入 boot 独立程序，boot 程序将自身复制到高位地址的内存从而为操作系统释放低位地址的内存。</p>
<p>复制完成后，boot 程序读取启动设备的根目录。boot 程序要理解文件系统和目录格式。然后 boot 程序被调入内核，把控制权移交给内核。直到这里，boot 完成了它的工作。系统内核开始运行。</p>
<p>内核启动代码是使用<code class="java">
汇编语言</code>完成的，主要包括创建内核堆栈、识别 CPU 类型、计算内存、禁用中断、启动内存管理单元等，然后调用 C 语言的 main 函数执行操作系统部分。</p>
<p>这部分也会做很多事情，首先会分配一个消息缓冲区来存放调试出现的问题，调试信息会写入缓冲区。如果调试出现错误，这些信息可以通过诊断程序调出来。</p>
<p>然后操作系统会进行自动配置，检测设备，加载配置文件，被检测设备如果做出响应，就会被添加到已链接的设备表中，如果没有相应，就归为未连接直接忽略。</p>
<p>配置完所有硬件后，接下来要做的就是仔细手工处理进程0，设置其堆栈，然后运行它，执行初始化、配置时钟、挂载文件系统。创建 <code class="java">
init 进程(进程 1 )</code> 和 <code class="java">
守护进程(进程 2)</code>。</p>
<p>init 进程会检测它的标志以确定它是否为单用户还是多用户服务。在前一种情况中，它会调用 fork 函数创建一个 shell 进程，并且等待这个进程结束。后一种情况调用 fork 函数创建一个运行系统初始化的 shell 脚本（即 &#x2F;etc&#x2F;rc）的进程，这个进程可以进行文件系统一致性检测、挂载文件系统、开启守护进程等。</p>
<p>然后 &#x2F;etc&#x2F;rc 这个进程会从 &#x2F;etc&#x2F;ttys 中读取数据，&#x2F;etc&#x2F;ttys 列出了所有的终端和属性。对于每一个启用的终端，这个进程调用 fork 函数创建一个自身的副本，进行内部处理并运行一个名为 <code class="java">
getty</code> 的程序。</p>
<p>getty 程序会在终端上输入</p>
<pre class="line-numbers language-java"><code class="language-java">
login<span class="token operator">:</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>等待用户输入用户名，在输入用户名后，getty 程序结束，登陆程序 <code class="java">
/bin/login</code> 开始运行。login 程序需要输入密码，并与保存在 <code class="java">
/etc/passwd</code> 中的密码进行对比，如果输入正确，login 程序以用户 shell 程序替换自身，等待第一个命令。如果不正确，login 程序要求输入另一个用户名。</p>
<p>整个系统启动过程如下</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFIMVl3VkpuZ2RCMzVpYUJub0kzTkJoMnFMVm5MOUZsakhkQ0t0dW5OYUt4M3VQbUJXYnVxZjFBLzY0MA?x-oss-process=image/format,png">

<h2 id="Linux-内存管理"><a href="#Linux-内存管理" class="headerlink" title="Linux 内存管理"></a>Linux 内存管理</h2><p>Linux 内存管理模型非常直接明了，因为 Linux 的这种机制使其具有可移植性并且能够在内存管理单元相差不大的机器下实现 Linux，下面我们就来认识一下 Linux 内存管理是如何实现的。</p>
<h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>每个 Linux 进程都会有地址空间，这些地址空间由三个段区域组成：<strong>「text 段、data 段、stack 段」</strong>。下面是进程地址空间的示例。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFHSXNPYVlyVzBxQmZzYkttcHZSQzlrcmd5YndHeEFpYVNPSmN4WDRpY0JRZHduckRVMUIyaGVNUS82NDA?x-oss-process=image/format,png">

<p><code class="java">
数据段(data segment)</code> 包含了程序的变量、字符串、数组和其他数据的存储。数据段分为两部分，已经初始化的数据和尚未初始化的数据。其中<code class="java">
尚未初始化的数据</code>就是我们说的 BSS。数据段部分的初始化需要编译就期确定的常量以及程序启动就需要一个初始值的变量。所有 BSS 部分中的变量在加载后被初始化为 0 。</p>
<p>和 <code class="java">
代码段(Text segment)</code> 不一样，data segment 数据段可以改变。程序总是修改它的变量。而且，许多程序需要在执行时动态分配空间。Linux 允许数据段随着内存的分配和回收从而增大或者减小。为了分配内存，程序可以增加数据段的大小。在 C 语言中有一套标准库 <code class="java">
malloc</code> 经常用于分配内存。进程地址空间描述符包含动态分配的内存区域称为 <code class="java">
堆(heap)</code>。</p>
<p>第三部分段是 <code class="java">
栈段(stack segment)</code>。在大部分机器上，栈段会在虚拟内存地址顶部地址位置处，并向低位置处（向地址空间为 0 处）拓展。举个例子来说，在 32 位 x86 架构的机器上，栈开始于 <code class="java">
0xC0000000</code>，这是用户模式下进程允许可见的 3GB 虚拟地址限制。如果栈一直增大到超过栈段后，就会发生硬件故障并把页面下降一个页面。</p>
<p>当程序启动时，栈区域并不是空的，相反，它会包含所有的 shell 环境变量以及为了调用它而向 shell 输入的命令行。举个例子，当你输入</p>
<pre class="line-numbers language-java"><code class="language-java">
cp cxuan lx
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>时，cp 程序会运行并在栈中带着字符串 <code class="java">
cp cxuan lx</code> ，这样就能够找出源文件和目标文件的名称。</p>
<p>当两个用户运行在相同程序中，例如<code class="java">
编辑器(editor)</code>，那么就会在内存中保持编辑器程序代码的两个副本，但是这种方式并不高效。Linux 系统支持<code class="java">
共享文本段作</code>为替代。下面图中我们会看到 A 和 B 两个进程，它们有着相同的文本区域。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFpYURjMDAyczdoNjdaUGF5bk13d1Z3blI1WURRMnhjQm5yd1VQRVRNSlp0ZjREbENlbTRvSGlidy82NDA?x-oss-process=image/format,png">

<p>数据段和栈段只有在 fork 之后才会共享，共享也是共享未修改过的页面。如果任何一个都需要变大但是没有相邻空间容纳的话，也不会有问题，因为相邻的虚拟页面不必映射到相邻的物理页面上。</p>
<p>除了动态分配更多的内存，Linux 中的进程可以通过<code class="java">
内存映射文件</code>来访问文件数据。这个特性可以使我们把一个文件映射到进程空间的一部分而该文件就可以像位于内存中的字节数组一样被读写。把一个文件映射进来使得随机读写比使用 read 和 write 之类的 I&#x2F;O 系统调用要容易得多。共享库的访问就是使用了这种机制。如下所示</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFDaWNTY2lhRUZsdk1jOUg0YkhQSGh1NzJkaWF2UGZtS0NDUXdiQ2lhcXJWM09RaWFOc0JWdkZVNThmUS82NDA?x-oss-process=image/format,png">

<p>我们可以看到两个相同文件会被映射到相同的物理地址上，但是它们属于不同的地址空间。</p>
<p>映射文件的优点是，两个或多个进程可以同时映射到同一文件中，任意一个进程对文件的写操作对其他文件可见。通过使用映射临时文件的方式，可以为多线程共享内存<code class="java">
提供高带宽</code>，临时文件在进程退出后消失。但是实际上，并没有两个相同的地址空间，因为每个进程维护的打开文件和信号不同。</p>
<h3 id="Linux-内存管理系统调用"><a href="#Linux-内存管理系统调用" class="headerlink" title="Linux 内存管理系统调用"></a>Linux 内存管理系统调用</h3><p>下面我们探讨一下关于内存管理的系统调用方式。事实上，POSIX 并没有给内存管理指定任何的系统调用。然而，Linux 却有自己的内存系统调用，主要系统调用如下</p>
<th width="339">系统调用</th><th width="152">描述</th>
|------
<td width="19">s = brk(addr)</td><td width="152">改变数据段大小</td>
<td width="19">a = mmap(addr,len,prot,flags,fd,offset)</td><td width="152">进行映射</td>
<td width="19">s = unmap(addr,len)</td><td width="152">取消映射</td>



<p>如果遇到错误，那么 s 的返回值是 -1，a 和 addr 是内存地址，len 表示的是长度，prot 表示的是控制保护位，flags 是其他标志位，fd 是文件描述符，offset 是文件偏移量。</p>
<p><code class="java">
brk</code> 通过给出超过数据段之外的第一个字节地址来指定数据段的大小。如果新的值要比原来的大，那么数据区会变得越来越大，反之会越来越小。</p>
<p><code class="java">
mmap</code> 和 <code class="java">
unmap</code> 系统调用会控制映射文件。mmp 的第一个参数 addr 决定了文件映射的地址。它必须是页面大小的倍数。如果参数是 0，系统会分配地址并返回 a。第二个参数是长度，它告诉了需要映射多少字节。它也是页面大小的倍数。prot 决定了映射文件的保护位，保护位可以标记为 <strong>「可读、可写、可执行或者这些的结合」</strong>。第四个参数 flags 能够控制文件是私有的还是可读的以及 addr 是必须的还是只是进行提示。第五个参数 fd 是要映射的文件描述符。只有打开的文件是可以被映射的，因此如果想要进行文件映射，必须打开文件；最后一个参数 offset 会指示文件从什么时候开始，并不一定每次都要从零开始。</p>
<h3 id="Linux-内存管理实现"><a href="#Linux-内存管理实现" class="headerlink" title="Linux 内存管理实现"></a>Linux 内存管理实现</h3><p>内存管理系统是操作系统最重要的部分之一。从计算机早期开始，我们实际使用的内存都要比系统中实际存在的内存多。<code class="java">
内存分配策略</code>克服了这一限制，并且其中最有名的就是 <code class="java">
虚拟内存(virtual memory)</code>。通过在多个竞争的进程之间共享虚拟内存，虚拟内存得以让系统有更多的内存。虚拟内存子系统主要包括下面这些概念。</p>
<p><strong>「大地址空间」</strong></p>
<p>操作系统使系统使用起来好像比实际的物理内存要大很多，那是因为虚拟内存要比物理内存大很多倍。</p>
<p><strong>「保护」</strong></p>
<p>系统中的每个进程都会有自己的虚拟地址空间。这些虚拟地址空间彼此完全分开，因此运行一个应用程序的进程不会影响另一个。并且，硬件虚拟内存机制允许内存保护关键内存区域。</p>
<p><strong>「内存映射」</strong></p>
<p>内存映射用来向进程地址空间映射图像和数据文件。在内存映射中，文件的内容直接映射到进程的虚拟空间中。</p>
<p><strong>「公平的物理内存分配」</strong></p>
<p>内存管理子系统允许系统中的每个正在运行的进程公平分配系统的物理内存。</p>
<p><strong>「共享虚拟内存」</strong></p>
<p>尽管虚拟内存让进程有自己的内存空间，但是有的时候你是需要共享内存的。例如几个进程同时在 shell 中运行，这会涉及到 IPC 的进程间通信问题，这个时候你需要的是共享内存来进行信息传递而不是通过拷贝每个进程的副本独立运行。</p>
<p>下面我们就正式探讨一下什么是 <code class="java">
虚拟内存</code></p>
<h4 id="虚拟内存的抽象模型"><a href="#虚拟内存的抽象模型" class="headerlink" title="虚拟内存的抽象模型"></a>虚拟内存的抽象模型</h4><p>在考虑 Linux 用于支持虚拟内存的方法之前，考虑一个不会被太多细节困扰的抽象模型是很有用的。</p>
<p>处理器在执行指令时，会从内存中读取指令并将其<code class="java">
解码(decode)</code>，在指令解码时会获取某个位置的内容并将他存到内存中。然后处理器继续执行下一条指令。这样，处理器总是在访问存储器以获取指令和存储数据。</p>
<p>在虚拟内存系统中，所有的地址空间都是虚拟的而不是物理的。但是实际存储和提取指令的是物理地址，所以需要让处理器根据操作系统维护的一张表将虚拟地址转换为物理地址。</p>
<p>为了简单的完成转换，虚拟地址和物理地址会被分为固定大小的块，称为 <code class="java">
页(page)</code>。这些页有相同大小，如果页面大小不一样的话，那么操作系统将很难管理。Alpha AXP系统上的 Linux 使用 8 KB 页面，而 Intel x86 系统上的 Linux 使用 4 KB 页面。每个页面都有一个唯一的编号，即<code class="java">
页面框架号（PFN）</code>。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFabXVCR3FUREQ5aWFZb25Jd244Sm1RQ1A2dXlWOEhXemtBTWhObGliWXNnR0drN1FFaWNGOVRpYTlRLzY0MA?x-oss-process=image/format,png">

<p>上面就是 Linux 内存映射模型了，在这个页模型中，虚拟地址由两部分组成：<strong>「偏移量和虚拟页框号」</strong>。每次处理器遇到虚拟地址时都会提取偏移量和虚拟页框号。处理器必须将虚拟页框号转换为物理页号，然后以正确的偏移量的位置访问物理页。</p>
<p>上图中展示了两个进程 A 和 B 的虚拟地址空间，每个进程都有自己的页表。这些页表将进程中的虚拟页映射到内存中的物理页中。页表中每一项均包含</p>
<ul>
<li><code class="java">
有效标志(valid flag)</code>：表明此页表条目是否有效- 该条目描述的物理页框号- 访问控制信息，页面使用方式，是否可写以及是否可以执行代码<br>要将处理器的虚拟地址映射为内存的物理地址，首先需要计算虚拟地址的页框号和偏移量。页面大小为 2 的次幂，可以通过移位完成操作。</li>
</ul>
<p>如果当前进程尝试访问虚拟地址，但是访问不到的话，这种情况称为 <code class="java">
缺页异常</code>，此时虚拟操作系统的错误地址和页面错误的原因将通知操作系统。</p>
<p>通过以这种方式将虚拟地址映射到物理地址，虚拟内存可以以任何顺序映射到系统的物理页面。</p>
<h4 id="按需分页"><a href="#按需分页" class="headerlink" title="按需分页"></a>按需分页</h4><p>由于物理内存要比虚拟内存少很多，因此操作系统需要注意尽量避免直接使用<code class="java">
低效</code>的物理内存。节省物理内存的一种方式是仅加载执行程序当前使用的页面（这何尝不是一种懒加载的思想呢？）。例如，可以运行数据库来查询数据库，在这种情况下，不是所有的数据都装入内存，只装载需要检查的数据。这种仅仅在需要时才将虚拟页面加载进内中的技术称为按需分页。</p>
<h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><p>如果某个进程需要将虚拟页面传入内存，但是此时没有可用的物理页面，那么操作系统必须丢弃物理内存中的另一个页面来为该页面腾出空间。</p>
<p>如果页面已经修改过，那么操作系统必须保留该页面的内容，以便以后可以访问它。这种类型的页面被称为脏页，当将其从内存中移除时，它会保存在称为<code class="java">
交换文件</code>的特殊文件中。相对于处理器和物理内存的速度，对交换文件的访问非常慢，并且操作系统需要兼顾将页面写到磁盘的以及将它们保留在内存中以便再次使用。</p>
<p>Linux 使用<code class="java">
最近最少使用(LRU)</code>页面老化技术来公平的选择可能会从系统中删除的页面，这个方案涉及系统中的每个页面，页面的年龄随着访问次数的变化而变化，如果某个页面访问次数多，那么该页就表示越 <code class="java">
年轻</code>，如果某个呃页面访问次数太少，那么该页越容易被<code class="java">
换出</code>。</p>
<h4 id="物理和虚拟寻址模式"><a href="#物理和虚拟寻址模式" class="headerlink" title="物理和虚拟寻址模式"></a>物理和虚拟寻址模式</h4><p>大多数多功能处理器都支持 <code class="java">
物理地址</code>模式和<code class="java">
虚拟地址</code>模式的概念。物理寻址模式不需要页表，并且处理器不会在此模式下尝试执行任何地址转换。Linux 内核被链接在物理地址空间中运行。</p>
<p>Alpha AXP 处理器没有物理寻址模式。相反，它将内存空间划分为几个区域，并将其中两个指定为物理映射的地址。此内核地址空间称为 KSEG 地址空间，它包含从 0xfffffc0000000000 向上的所有地址。为了从 KSEG 中链接的代码（按照定义，内核代码）执行或访问其中的数据，该代码必须在内核模式下执行。链接到 Alpha 上的 Linux内核以从地址 0xfffffc0000310000 执行。</p>
<h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>页面表的每一项还包含访问控制信息，访问控制信息主要检查进程是否应该访问内存。</p>
<p>必要时需要对内存进行<code class="java">
访问限制</code>。例如包含可执行代码的内存，自然是只读内存；操作系统不应允许进程通过其可执行代码写入数据。相比之下，包含数据的页面可以被写入，但是尝试执行该内存的指令将失败。大多数处理器至少具有两种执行模式：内核态和用户态。你不希望访问用户执行内核代码或内核数据结构，除非处理器以内核模式运行。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlF0aktOY3JIN0Z2TFpITGpNWFBRYXlwNTBVRldneEgwdEh0a3ZyaWF1RFdZZDduRVM5cmI0ejl3LzY0MA?x-oss-process=image/format,png">

<p>访问控制信息被保存在上面的 Page Table Entry ，页表项中，上面这幅图是 Alpha AXP的 PTE。位字段具有以下含义</p>
<ul>
<li>V<br>表示 valid ，是否有效位</li>
<li>FOR<br>读取时故障，在尝试读取此页面时出现故障</li>
<li>FOW<br>写入时错误，在尝试写入时发生错误</li>
<li>FOE<br>执行时发生错误，在尝试执行此页面中的指令时，处理器都会报告页面错误并将控制权传递给操作系统，</li>
<li>ASM<br>地址空间匹配，当操作系统希望清除转换缓冲区中的某些条目时，将使用此选项。</li>
<li>GH<br>当在使用<code class="java">
单个转换缓冲区</code>条目而不是<code class="java">
多个转换缓冲区</code>条目映射整个块时使用的提示。</li>
<li>KRE<br>内核模式运行下的代码可以读取页面</li>
<li>URE<br>用户模式下的代码可以读取页面</li>
<li>KWE<br>以内核模式运行的代码可以写入页面</li>
<li>UWE<br>以用户模式运行的代码可以写入页面</li>
<li>页框号<br>对于设置了 V 位的 PTE，此字段包含此 PTE 的物理页面帧号（页面帧号）。对于无效的 PTE，如果此字段不为零，则包含有关页面在交换文件中的位置的信息。</li>
</ul>
<p>除此之外，Linux 还使用了两个位</p>
<ul>
<li>_PAGE_DIRTY<br>如果已设置，则需要将页面写出到交换文件中</li>
<li>_PAGE_ACCESSED<br>Linux 用来将页面标记为已访问。</li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>上面的虚拟内存抽象模型可以用来实施，但是效率不会太高。操作系统和处理器设计人员都尝试提高性能。但是除了提高处理器，内存等的速度之外，最好的方法就是维护有用信息和数据的高速缓存，从而使某些操作更快。在 Linux 中，使用很多和内存管理有关的缓冲区，使用缓冲区来提高效率。</p>
<h4 id="缓冲区缓存"><a href="#缓冲区缓存" class="headerlink" title="缓冲区缓存"></a>缓冲区缓存</h4><p>缓冲区高速缓存包含<code class="java">
块设备</code>驱动程序使用的数据缓冲区。</p>
<p>还记得什么是块设备么？这里回顾下</p>
<p>块设备是一个能存储<code class="java">
固定大小块</code>信息的设备，它支持<strong>「以固定大小的块，扇区或群集读取和（可选）写入数据」</strong>。每个块都有自己的<code class="java">
物理地址</code>。通常块的大小在 512 - 65536 之间。所有传输的信息都会以<code class="java">
连续</code>的块为单位。块设备的基本特征是每个块都较为对立，能够独立的进行读写。常见的块设备有 <strong>「硬盘、蓝光光盘、USB 盘」</strong></p>
<p>与字符设备相比，块设备通常需要较少的引脚。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFmUFRpYzF4MWljOTdqZTRDTWlhOXdvYk93Zkt0cndZZ3JpY3dpYUVJVFVvSEVQaWI0MGpabUtwUXFXS3cvNjQw?x-oss-process=image/format,png">

<p>缓冲区高速缓存通过<code class="java">
设备标识符</code>和块编号用于快速查找数据块。如果可以在缓冲区高速缓存中找到数据，则无需从物理块设备中读取数据，这种访问方式要快得多。</p>
<h4 id="页缓存"><a href="#页缓存" class="headerlink" title="页缓存"></a>页缓存</h4><p>页缓存用于加快对磁盘上图像和数据的访问</p>
<p>它用于一次一页地缓存文件中的内容，并且可以通过文件和文件中的偏移量进行访问。当页面从磁盘读入内存时，它们被缓存在页面缓存中。</p>
<h4 id="交换区缓存"><a href="#交换区缓存" class="headerlink" title="交换区缓存"></a>交换区缓存</h4><p>仅仅已修改（脏页）被保存在交换文件中</p>
<p>只要这些页面在写入交换文件后没有修改，则下次交换该页面时，无需将其写入交换文件，因为该页面已在交换文件中。可以直接丢弃。在大量交换的系统中，这节省了许多不必要的和昂贵的磁盘操作。</p>
<h4 id="硬件缓存"><a href="#硬件缓存" class="headerlink" title="硬件缓存"></a>硬件缓存</h4><p>处理器中通常使用一种硬件缓存。页表条目的缓存。在这种情况下，处理器并不总是直接读取页表，而是根据需要缓存页的翻译。这些是<code class="java">
转换后备缓冲区</code> 也被称为 <code class="java">
TLB</code>，包含来自系统中一个或多个进程的页表项的缓存副本。</p>
<p>引用虚拟地址后，处理器将尝试查找匹配的 TLB 条目。如果找到，则可以将虚拟地址直接转换为物理地址，并对数据执行正确的操作。如果处理器找不到匹配的 TLB 条目， 它通过向操作系统发信号通知已发生 TLB 丢失获得操作系统的支持和帮助。系统特定的机制用于将该异常传递给可以修复问题的操作系统代码。操作系统为地址映射生成一个新的 TLB 条目。清除异常后，处理器将再次尝试转换虚拟地址。这次能够执行成功。</p>
<p>使用缓存也存在缺点，为了节省精力，Linux 必须使用更多的时间和空间来维护这些缓存，并且如果缓存损坏，系统将会崩溃。</p>
<h3 id="Linux-页表"><a href="#Linux-页表" class="headerlink" title="Linux 页表"></a>Linux 页表</h3><p>Linux 假定页表分为三个级别。访问的每个页表都包含下一级页表</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFJSktuNHpmNnpRWnVnUlFWNmh4c0s4QjhLZmlic01waWFFYk52VnYyRFJXV0dXeElGb1Rtd2xsdy82NDA?x-oss-process=image/format,png">

<p>图中的 PDG 表示全局页表，当创建一个新的进程时，都要为新进程创建一个新的页面目录，即 PGD。</p>
<p>要将虚拟地址转换为物理地址，处理器必须获取每个级别字段的内容，将其转换为包含页表的物理页的偏移量，并读取下一级页表的页框号。这样重复三次，直到找到包含虚拟地址的物理页面的页框号为止。</p>
<p>Linux 运行的每个平台都必须提供翻译宏，这些宏允许内核遍历特定进程的页表。这样，内核无需知道页表条目的格式或它们的排列方式。</p>
<h3 id="页分配和取消分配"><a href="#页分配和取消分配" class="headerlink" title="页分配和取消分配"></a>页分配和取消分配</h3><p>对系统中物理页面有很多需求。例如，当图像加载到内存中时，操作系统需要分配页面。</p>
<p>系统中所有物理页面均由 <code class="java">
mem_map</code> 数据结构描述，这个数据结构是 <code class="java">
mem_map_t</code> 的列表。它包括一些重要的属性</p>
<ul>
<li>count ：这是页面的用户数计数，当页面在多个进程之间共享时，计数大于 1- age：这是描述页面的年龄，用于确定页面是否适合丢弃或交换- map_nr ：这是此mem_map_t描述的物理页框号。<br>页面分配代码使用 <code class="java">
free_area</code>向量查找和释放页面，free_area 的每个元素都包含有关页面块的信息。</li>
</ul>
<h4 id="页面分配"><a href="#页面分配" class="headerlink" title="页面分配"></a>页面分配</h4><p>Linux 的页面分配使用一种著名的伙伴算法来进行页面的分配和取消分配。页面以 2 的幂为单位进行块分配。这就意味着它可以分配 1页、2 页、4页等等，只要系统中有足够可用的页面来满足需求就可以。判断的标准是<strong>「nr_free_pages&gt; min_free_pages」</strong>，如果满足，就会在 free_area 中搜索所需大小的页面块完成分配。free_area 的每个元素都有该大小的块的已分配页面和空闲页面块的映射。</p>
<p>分配算法会搜索请求大小的页面块。如果没有任何请求大小的页面块可用的话，会搜寻一个是请求大小二倍的页面块，然后重复，直到一直搜寻完 free_area 找到一个页面块为止。如果找到的页面块要比请求的页面块大，就会对找到的页面块进行细分，直到找到合适的大小块为止。</p>
<p>因为每个块都是 2 的次幂，所以拆分过程很容易，因为你只需将块分成两半即可。空闲块在适当的队列中排队，分配的页面块返回给调用者。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFWU0Y5SXcxQVp4WTdyd2ppYWliMW44TDRsNFRYN0JCY3B0c2JPTmpIclNuZU5ZM21mTHNZS0gyUS82NDA?x-oss-process=image/format,png">

<p>如果请求一个 2 个页的块，则 4 页的第一个块（从第 4 页的框架开始）将被分成两个 2 页的块。第一个页面（从第 4 页的帧开始）将作为分配的页面返回给调用方，第二个块（从第 6 页的页面开始）将作为 2 页的空闲块排队到 free_area 数组的元素 1 上。</p>
<h4 id="页面取消分配"><a href="#页面取消分配" class="headerlink" title="页面取消分配"></a>页面取消分配</h4><p>上面的这种内存方式最造成一种后果，那就是内存的碎片化，会将较大的空闲页面分成较小的页面。页面解除分配代码会尽可能将页面重新组合成为更大的空闲块。每释放一个页面，都会检查相同大小的相邻的块，以查看是否空闲。如果是，则将其与新释放的页面块组合以形成下一个页面大小块的新的自由页面块。每次将两个页面块重新组合为更大的空闲页面块时，页面释放代码就会尝试将该页面块重新组合为更大的空闲页面。通过这种方式，可用页面的块将尽可能多地使用内存。</p>
<p>例如上图，如果要释放第 1 页的页面，则将其与已经空闲的第 0 页页面框架组合在一起，并作为大小为 2页的空闲块排队到 free_area 的元素 1 中</p>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>内核有两种类型的内存映射：<code class="java">
共享型(shared)</code> 和<code class="java">
私有型(private)</code>。私有型是当进程为了只读文件，而不写文件时使用，这时，私有映射更加高效。但是，任何对私有映射页的写操作都会导致内核停止映射该文件中的页。所以，写操作既不会改变磁盘上的文件，对访问该文件的其它进程也是不可见的。</p>
<h3 id="按需分页-1"><a href="#按需分页-1" class="headerlink" title="按需分页"></a>按需分页</h3><p>一旦可执行映像被内存映射到虚拟内存后，它就可以被执行了。因为只将映像的开头部分物理的拉入到内存中，因此它将很快访问物理内存尚未存在的虚拟内存区域。当进程访问没有有效页表的虚拟地址时，操作系统会报告这项错误。</p>
<p>页面错误描述页面出错的虚拟地址和引起的内存访问（RAM）类型。</p>
<p>Linux 必须找到代表发生页面错误的内存区域的 vm_area_struct 结构。由于搜索 vm_area_struct 数据结构对于有效处理页面错误至关重要，因此它们以 <code class="java">
AVL（Adelson-Velskii和Landis）</code>树结构链接在一起。如果引起故障的虚拟地址没有 <code class="java">
vm_area_struct</code> 结构，则此进程已经访问了非法地址，Linux 会向进程发出 <code class="java">
SIGSEGV</code> 信号，如果进程没有用于该信号的处理程序，那么进程将会终止。</p>
<p>然后，Linux 会针对此虚拟内存区域所允许的访问类型，检查发生的页面错误类型。如果该进程以非法方式访问内存，例如写入仅允许读的区域，则还会发出内存访问错误信号。</p>
<p>现在，Linux 已确定页面错误是合法的，因此必须对其进行处理。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>在 Linux 中，最直观、最可见的部分就是 <code class="java">
文件系统(file system)</code>。下面我们就来一起探讨一下关于 Linux 中国的文件系统，系统调用以及文件系统实现背后的原理和思想。这些思想中有一些来源于 MULTICS，现在已经被 Windows 等其他操作系统使用。Linux 的设计理念就是 <code class="java">
小的就是好的(Small is Beautiful)</code> 。虽然 Linux 只是使用了最简单的机制和少量的系统调用，但是 Linux 却提供了强大而优雅的文件系统。</p>
<h3 id="Linux-文件系统基本概念"><a href="#Linux-文件系统基本概念" class="headerlink" title="Linux 文件系统基本概念"></a>Linux 文件系统基本概念</h3><p>Linux 在最初的设计是 MINIX1 文件系统，它只支持 14 字节的文件名，它的最大文件只支持到 64 MB。在 MINIX 1 之后的文件系统是 ext 文件系统。ext 系统相较于 MINIX 1 来说，在支持字节大小和文件大小上均有很大提升，但是 ext 的速度仍没有 MINIX 1 快，于是，ext 2 被开发出来，它能够支持长文件名和大文件，而且具有比 MINIX 1 更好的性能。这使他成为 Linux 的主要文件系统。只不过 Linux 会使用 <code class="java">
VFS</code> 曾支持多种文件系统。在 Linux 链接时，用户可以动态的将不同的文件系统挂载倒 VFS 上。</p>
<p>Linux 中的文件是一个任意长度的字节序列，Linux 中的文件可以包含任意信息，比如 ASCII 码、二进制文件和其他类型的文件是不加区分的。</p>
<p>为了方便起见，文件可以被组织在一个目录中，目录存储成文件的形式在很大程度上可以作为文件处理。目录可以有子目录，这样形成有层次的文件系统，Linux 系统下面的根目录是 <code class="java">
/</code> ，它通常包含了多个子目录。字符 <code class="java">
/</code> 还用于对目录名进行区分，例如 <strong>「&#x2F;usr&#x2F;cxuan」</strong> 表示的就是根目录下面的 usr 目录，其中有一个叫做 cxuan 的子目录。</p>
<p>下面我们介绍一下 Linux 系统根目录下面的目录名</p>
<ul>
<li><code class="java">
/bin</code>，它是重要的二进制应用程序，包含二进制文件，系统的所有用户使用的命令都在这里- <code class="java">
/boot</code>，启动包含引导加载程序的相关文件- <code class="java">
/dev</code>，包含设备文件，终端文件，USB 或者连接到系统的任何设备- <code class="java">
/etc</code>，配置文件，启动脚本等，包含所有程序所需要的配置文件，也包含了启动&#x2F;停止单个应用程序的启动和关闭 shell 脚本- <code class="java">
/home</code>，本地主要路径，所有用户用 home 目录存储个人信息- <code class="java">
/lib</code>，系统库文件，包含支持位于 &#x2F;bin 和 &#x2F;sbin 下的二进制库文件- <code class="java">
/lost+found</code>，在根目录下提供一个遗失+查找系统，必须在 root 用户下才能查看当前目录下的内容- <code class="java">
/media</code>，挂载可移动介质- <code class="java">
/mnt</code>，挂载文件系统- <code class="java">
/opt</code>，提供一个可选的应用程序安装目录- <code class="java">
/proc</code>，特殊的动态目录，用于维护系统信息和状态，包括当前运行中进程信息- <code class="java">
/root</code>，root 用户的主要目录文件夹- <code class="java">
/sbin</code>，重要的二进制系统文件- <code class="java">
/tmp</code>， 系统和用户创建的临时文件，系统重启时，这个目录下的文件都会被删除- <code class="java">
/usr</code>，包含绝大多数用户都能访问的应用程序和文件- <code class="java">
/var</code>，经常变化的文件，诸如日志文件或数据库等<br>在 Linux 中，有两种路径，一种是 <code class="java">
绝对路径(absolute path)</code> ，绝对路径告诉你从根目录下查找文件，绝对路径的缺点是太长而且不太方便。还有一种是 <code class="java">
相对路径(relative path)</code> ，相对路径所在的目录也叫做<code class="java">
工作目录(working directory)</code>。</li>
</ul>
<p>如果 <code class="java">
/usr/local/books</code> 是工作目录，那么 shell 命令</p>
<pre class="line-numbers language-java"><code class="language-java">
cp books books<span class="token operator">-</span>replica 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>就表示的是相对路径，而</p>
<pre class="line-numbers language-java"><code class="language-java">
cp <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>books<span class="token operator">/</span>books <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>books<span class="token operator">/</span>books<span class="token operator">-</span>replica
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>则表示的是绝对路径。</p>
<p>在 Linux 中经常出现一个用户使用另一个用户的文件或者使用文件树结构中的文件。两个用户共享同一个文件，这个文件位于某个用户的目录结构中，另一个用户需要使用这个文件时，必须通过绝对路径才能引用到他。如果绝对路径很长，那么每次输入起来会变的非常麻烦，所以 Linux 提供了一种 <code class="java">
链接(link)</code> 机制。</p>
<p>举个例子，下面是一个使用链接之前的图</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFheGljM2ljVVFxYzJSWUVpYk5vZmliUzZ2MjVpYmxHMkF2SEVSaGVpY1daeWN3Y1RqQ0ZHQ0MwUXo4WlEvNjQw?x-oss-process=image/format,png">

<p>以上所示，比如有两个工作账户 jianshe 和 cxuan，jianshe 想要使用 cxuan 账户下的 A 目录，那么它可能会输入 <code class="java">
/usr/cxuan/A</code> ，这是一种未使用链接之后的图。</p>
<p>使用链接后的示意如下</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFxMnhXR3dlQm5nQUF0SUZicXNpYmtHUUNwaHgwNnphVU1rNXNkYkZJRlRtN2FSNmhrRVppYVFWQS82NDA?x-oss-process=image/format,png">

<p>现在，jianshe 可以创建一个链接来使用 cxuan 下面的目录了。‘</p>
<p>当一个目录被创建出来后，有两个目录项也同时被创建出来，它们就是 <code class="java">
.</code> 和 <code class="java">
..</code> ，前者代表工作目录自身，后者代表该目录的父目录，也就是该目录所在的目录。这样一来，在 &#x2F;usr&#x2F;jianshe 中访问 cxuan 中的目录就是 <code class="java">
../cxuan/xxx</code></p>
<p>Linux 文件系统不区分磁盘的，这是什么意思呢？一般来说，一个磁盘中的文件系统相互之间保持独立，如果一个文件系统目录想要访问另一个磁盘中的文件系统，在 Windows 中你可以像下面这样。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFEUjJWa1FMN05EdnJBcEY1TmZDdWliaWNOdWxzSWJjN2tLalgxTG9pY1BMNmV5Zm1GaWNPS1BGdjBRLzY0MA?x-oss-process=image/format,png">

<p>两个文件系统分别在不同的磁盘中，彼此保持独立。</p>
<p>而在 Linux 中，是支持<code class="java">
挂载</code>的，它允许一个磁盘挂在到另外一个磁盘上，那么上面的关系会变成下面这样</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFkNUdTM1pwMHNUT1dpYjdHNkQyTmpoM2NoOE56WG45N01XZ3VmclZNSUpaYUl2U3NFRHkxS25nLzY0MA?x-oss-process=image/format,png">

<p>挂在之后，两个文件系统就不再需要关心文件系统在哪个磁盘上了，两个文件系统彼此可见。</p>
<p>Linux 文件系统的另外一个特性是支持 <code class="java">
加锁(locking)</code>。在一些应用中会出现两个或者更多的进程同时使用同一个文件的情况，这样很可能会导致<code class="java">
竞争条件(race condition)</code>。一种解决方法是对其进行加不同粒度的锁，就是为了防止某一个进程只修改某一行记录从而导致整个文件都不能使用的情况。</p>
<p>POSIX 提供了一种灵活的、不同粒度级别的锁机制，允许一个进程使用一个不可分割的操作对一个字节或者整个文件进行加锁。加锁机制要求尝试加锁的进程指定其 <strong>「要加锁的文件，开始位置以及要加锁的字节」</strong></p>
<p>Linux 系统提供了两种锁：<strong>「共享锁和互斥锁」</strong>。如果文件的一部分已经加上了共享锁，那么再加排他锁是不会成功的；如果文件系统的一部分已经被加了互斥锁，那么在互斥锁解除之前的任何加锁都不会成功。为了成功加锁、请求加锁的部分的所有字节都必须是可用的。</p>
<p>在加锁阶段，进程需要设计好加锁失败后的情况，也就是判断加锁失败后是否选择阻塞，如果选择阻塞式，那么当已经加锁的进程中的锁被删除时，这个进程会解除阻塞并替换锁。如果进程选择非阻塞式的，那么就不会替换这个锁，会立刻从系统调用中返回，标记状态码表示是否加锁成功，然后进程会选择下一个时间再次尝试。</p>
<p>加锁区域是可以重叠的。下面我们演示了三种不同条件的加锁区域。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFEM2I4RWVHZFhyOTVUa0pQUGh1WWhkaWFpY01JUEJJbVRIbk1YNnRLeVRiTjFLeDdNdzg3TnE5US82NDA?x-oss-process=image/format,png">

<p>如上图所示，A 的共享锁在第四字节到第八字节进行加锁</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFobFF0TnpsOTF4TDFxN0Myd2pMbXJFbGJyazlucVhHc0g4ZnZHMGliTnVOYVQyajNVSG1nUEdBLzY0MA?x-oss-process=image/format,png">

<p>如上图所示，进程在 A 和 B 上同时加了共享锁，其中 6 - 8 字节是重叠锁</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFGYU85N2R6b3NCMGhhU0hKeWlhOUhFUXJsN2tEN1l6MTZoMDBsTFV5VTJtcDEwU3E3YW94RVBRLzY0MA?x-oss-process=image/format,png">

<p>如上图所示，进程 A 和 B 和 C 同时加了共享锁，那么第六字节和第七字节是共享锁。</p>
<p>如果此时一个进程尝试在第 6 个字节处加锁，此时会设置失败并阻塞，由于该区域被 A B C 同时加锁，那么只有等到 A B C 都释放锁后，进程才能加锁成功。</p>
<h3 id="Linux-文件系统调用"><a href="#Linux-文件系统调用" class="headerlink" title="Linux 文件系统调用"></a>Linux 文件系统调用</h3><p>许多系统调用都会和文件与文件系统有关。我们首先先看一下对单个文件的系统调用，然后再来看一下对整个目录和文件的系统调用。</p>
<p>为了创建一个新的文件，会使用到 <code class="java">
creat</code> 方法，注意没有 <code class="java">
e</code>。</p>
<blockquote>
</blockquote>
<p>  ❝<br>  这里说一个小插曲，曾经有人问 UNIX 创始人 Ken Thompson，如果有机会重新写 UNIX ，你会怎么办，他回答自己要把 creat 改成 create ，哈哈哈哈。<br>  ❞</p>
<p>这个系统调用的两个参数是文件名和保护模式</p>
<pre class="line-numbers language-java"><code class="language-java">
fd <span class="token operator">=</span> <span class="token function">creat</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">,</span>mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这段命令会创建一个名为 aaa 的文件，并根据 mode 设置文件的保护位。这些位决定了哪个用户可能访问文件、如何访问。</p>
<p>creat 系统调用不仅仅创建了一个名为 aaa 的文件，还会打开这个文件。为了允许后续的系统调用访问这个文件，这个 creat 系统调用会返回一个 <code class="java">
非负整数</code>， 这个就叫做 <code class="java">
文件描述符(file descriptor)</code>，也就是上面的 fd。</p>
<p>如果在已经存在的文件上调用了 creat 系统调用，那么该文件中的内容会被清除，从 0 开始。通过设置合适的参数，<code class="java">
open</code> 系统调用也能够创建文件。</p>
<p>下面让我们看一看主要的系统调用，如下表所示</p>
<p>|系统调用|描述<br>|——<br>|fd &#x3D; creat(name,mode)|一种创建一个新文件的方式<br>|fd &#x3D; open(file, …)|打开文件读、写或者读写<br>|s &#x3D; close(fd)|关闭一个打开的文件<br>|n &#x3D; read(fd, buffer, nbytes)|从文件中向缓存中读入数据<br>|n &#x3D; write(fd, buffer, nbytes)|从缓存中向文件中写入数据<br>|position &#x3D; lseek(fd, offset, whence)|移动文件指针<br>|s &#x3D; stat(name, &amp;buf)|获取文件信息<br>|s &#x3D; fstat(fd, &amp;buf)|获取文件信息<br>|s &#x3D; pipe(&amp;fd[0])|创建一个管道<br>|s &#x3D; fcntl(fd,…)|文件加锁等其他操作</p>
<p>为了对一个文件进行读写的前提是先需要打开文件，必须使用 creat 或者 open 打开，参数是打开文件的方式，是只读、可读写还是只写。open 系统调用也会返回文件描述符。打开文件后，需要使用 <code class="java">
close</code> 系统调用进行关闭。close 和 open 返回的 fd 总是未被使用的最小数量。</p>
<blockquote>
</blockquote>
<p>  ❝<br>  什么是文件描述符？文件描述符就是一个数字，这个数字标示了计算机操作系统中打开的文件。它描述了数据资源，以及访问资源的方式。<br>  ❞</p>
<p>当程序要求打开一个文件时，内核会进行如下操作</p>
<ul>
<li>授予访问权限- 在<code class="java">
全局文件表(global file table)</code>中创建一个<code class="java">
条目(entry)</code>- 向软件提供条目的位置<br>文件描述符由唯一的非负整数组成，系统上每个打开的文件至少存在一个文件描述符。文件描述符最初在 Unix 中使用，并且被包括 Linux，macOS 和 BSD 在内的现代操作系统所使用。</li>
</ul>
<p>当一个进程成功访问一个打开的文件时，内核会返回一个文件描述符，这个文件描述符指向全局文件表的 entry 项。这个文件表项包含文件的 inode 信息，字节位移，访问限制等。例如下图所示</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFpYkt5amMyUmhnckJpYUdhNG9ETjB0UkdSbTU2eVVvRnV3NmE0SXhhaWMxZVNxTURWRTlmOG1pYVZRLzY0MA?x-oss-process=image/format,png">

<p>默认情况下，前三个文件描述符为 <code class="java">
STDIN(标准输入)</code>、<code class="java">
STDOUT(标准输出)</code>、<code class="java">
STDERR(标准错误)</code>。</p>
<p>标准输入的文件描述符是 0 ，在终端中，默认为用户的键盘输入</p>
<p>标准输出的文件描述符是 1 ，在终端中，默认为用户的屏幕</p>
<p>与错误有关的默认数据流是 2，在终端中，默认为用户的屏幕。</p>
<p>在简单聊了一下文件描述符后，我们继续回到文件系统调用的探讨。</p>
<p>在文件系统调用中，开销最大的就是 read 和 write 了。read 和 write 都有三个参数</p>
<ul>
<li><code class="java">
文件描述符</code>：告诉需要对哪一个打开文件进行读取和写入- <code class="java">
缓冲区地址</code>：告诉数据需要从哪里读取和写入哪里- <code class="java">
统计</code>：告诉需要传输多少字节<br>这就是所有的参数了，这个设计非常简单轻巧。</li>
</ul>
<p>虽然几乎所有程序都按顺序读取和写入文件，但是某些程序需要能够随机访问文件的任何部分。与每个文件相关联的是一个指针，该指针指示文件中的当前位置。顺序读取（或写入）时，它通常指向要读取（写入）的下一个字节。如果指针在读取 1024 个字节之前位于 4096 的位置，则它将在成功读取系统调用后自动移至 5120 的位置。</p>
<p><code class="java">
Lseek</code> 系统调用会更改指针位置的值，以便后续对 read 或 write 的调用可以在文件中的任何位置开始，甚至可以超出文件末尾。</p>
<blockquote>
</blockquote>
<p>  ❝<br>  lseek &#x3D; Lseek ，段首大写。<br>  ❞</p>
<p>lseek 避免叫做 seek 的原因就是 seek 已经在之前 16 位的计算机上用于搜素功能了。</p>
<p><code class="java">
Lseek</code> 有三个参数：第一个是文件的文件描述符，第二个是文件的位置；第三个告诉文件位置是相对于文件的开头，当前位置还是文件的结尾</p>
<pre class="line-numbers language-java"><code class="language-java">
<span class="token function">lseek</span><span class="token punctuation">(</span><span class="token keyword">int</span> fildes<span class="token punctuation">,</span> off_t offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>lseek 的返回值是更改文件指针后文件中的绝对位置。lseek 是唯一从来不会造成真正磁盘查找的系统调用，它只是更新当前的文件位置，这个文件位置就是内存中的数字。</p>
<p>对于每个文件，Linux 都会跟踪文件模式（常规，目录，特殊文件），大小，最后修改时间以及其他信息。程序能够通过 <code class="java">
stat</code> 系统调用看到这些信息。第一个参数就是文件名，第二个是指向要放置请求信息结构的指针。这些结构的属性如下图所示。</p>
<p>|存储文件的设备<br>|——<br>|存储文件的设备<br>|i-node 编号<br>|文件模式(包括保护位信息)<br>|文件链接的数量<br>|文件所有者标识<br>|文件所属的组<br>|文件大小(字节)<br>|创建时间<br>|最后一个修改&#x2F;访问时间</p>
<p><code class="java">
fstat</code> 调用和 <code class="java">
stat</code> 相同，只有一点区别，fstat 可以对打开文件进行操作，而 stat 只能对路径进行操作。</p>
<p><code class="java">
pipe</code> 文件系统调用被用来创建 shell 管道。它会创建一系列的<code class="java">
伪文件</code>，来缓冲和管道组件之间的数据，并且返回读取或者写入缓冲区的文件描述符。在管道中，像是如下操作</p>
<pre class="line-numbers language-java"><code class="language-java">
sort <span class="token operator">&amp;</span>lt<span class="token punctuation">;</span>in <span class="token operator">|</span> head –<span class="token number">40</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>sort 进程将会输出到文件描述符1，也就是标准输出，写入管道中，而 head 进程将从管道中读入。在这种方式中，sort 只是从文件描述符 0 中读取并写入到文件描述符 1 （管道）中，甚至不知道它们已经被重定向了。如果没有重定向的话，sort 会自动的从键盘读入并输出到屏幕中。</p>
<p>最后一个系统调用是 <code class="java">
fcntl</code>，它用来锁定和解锁文件，应用共享锁和互斥锁，或者是执行一些文件相关的其他操作。</p>
<p>现在我们来关心一下和整体目录和文件系统相关的系统调用，而不是把精力放在单个的文件上，下面列出了这些系统调用，我们一起来看一下。</p>
<p>|系统调用|描述<br>|——<br>|s &#x3D; mkdir(path,mode)|创建一个新的目录<br>|s &#x3D; rmdir(path)|移除一个目录<br>|s &#x3D; link(oldpath,newpath)|创建指向已有文件的链接<br>|s &#x3D; unlink(path)|取消文件的链接<br>|s &#x3D; chdir(path)|改变工作目录<br>|dir &#x3D; opendir(path)|打开一个目录读取<br>|s &#x3D; closedir(dir)|关闭一个目录<br>|dirent &#x3D; readdir(dir)|读取一个目录项<br>|rewinddir(dir)|回转目录使其在此使用</p>
<p>可以使用 mkdir 和 rmdir 创建和删除目录。但是需要注意，只有目录为空时才可以删除。</p>
<p>创建一个指向已有文件的链接时会创建一个<code class="java">
目录项(directory entry)</code>。系统调用 link 来创建链接，oldpath 代表已有的路径，newpath 代表需要链接的路径，使用 <code class="java">
unlink</code> 可以删除目录项。当文件的最后一个链接被删除时，这个文件会被自动删除。</p>
<p>使用 <code class="java">
chdir</code> 系统调用可以改变工作目录。</p>
<p>最后四个系统调用是用于读取目录的。和普通文件类似，他们可以被打开、关闭和读取。每次调用 <code class="java">
readdir</code> 都会以固定的格式返回一个目录项。用户不能对目录执行写操作，但是可以使用 creat 或者 link 在文件夹中创建一个目录，或使用 unlink 删除一个目录。用户不能在目录中查找某个特定文件，但是可以使用 <code class="java">
rewindir</code> 作用于一个打开的目录，使他能在此从头开始读取。</p>
<h3 id="Linux-文件系统的实现"><a href="#Linux-文件系统的实现" class="headerlink" title="Linux 文件系统的实现"></a>Linux 文件系统的实现</h3><p>下面我们主要讨论一下 <code class="java">
虚拟文件系统(Virtual File System)</code>。VFS 对高层进程和应用程序隐藏了 Linux 支持的所有文件系统的区别，以及文件系统是存储在本地设备，还是需要通过网络访问远程设备。设备和其他特殊文件和 VFS 层相关联。接下来，我们就会探讨一下第一个 Linux 广泛传播的文件系统：<code class="java">
ext2</code>。随后，我们就会探讨 <code class="java">
ext4</code> 文件系统所做的改进。各种各样的其他文件系统也正在使用中。所有 Linux 系统都可以处理多个磁盘分区，每个磁盘分区上都有不同的文件系统。</p>
<h4 id="Linux-虚拟文件系统"><a href="#Linux-虚拟文件系统" class="headerlink" title="Linux 虚拟文件系统"></a>Linux 虚拟文件系统</h4><p>为了能够使应用程序能够在不同类型的本地或者远程设备上的文件系统进行交互，因为在 Linux 当中文件系统千奇百种，比较常见的有 EXT3、EXT4，还有基于内存的 ramfs、tmpfs 和基于网络的 nfs，和基于用户态的 fuse，当然 fuse 应该不能完全的文件系统，只能算是一个能把文件系统实现放到用户态的模块，满足了内核文件系统的接口，他们都是文件系统的一种实现。对于这些文件系统，Linux 做了一层抽象就是 <code class="java">
VFS</code>虚拟文件系统，</p>
<p>下表总结了 VFS 支持的四个主要的文件系统结构。</p>
<th width="146">对象</th><th width="345">描述</th>
|------
<td width="61">超级块</td><td width="345">特定的文件系统</td>
<td width="61">Dentry</td><td width="345">目录项，路径的一个组成部分</td>
<td width="61">I-node</td><td width="345">特定的文件</td>
<td width="61">File</td><td width="345">跟一个进程相关联的打开文件</td>



<p><code class="java">
超级块(superblock)</code> 包含了有关文件系统布局的重要信息，超级块如果遭到破坏那么就会导致整个文件系统不可读。</p>
<p><code class="java">
i-node</code> 索引节点，包含了每一个文件的描述符。</p>
<blockquote>
</blockquote>
<p>  ❝<br>  在 Linux 中，目录和设备也表示为文件，因为它们具有对应的 i-node<br>  ❞</p>
<p>超级块和索引块所在的文件系统都在磁盘上有对应的结构。</p>
<p>为了便于某些目录操作和路径遍历，比如 &#x2F;usr&#x2F;local&#x2F;cxuan，VFS 支持一个 <code class="java">
dentry</code> 数据结构，该数据结构代表着目录项。这个 dentry 数据结构有很多东西（<a target="_blank" rel="noopener" href="http://books.gigatux.nl/mirror/kerneldevelopment/0672327201/ch12lev1sec7.html%EF%BC%89%E8%BF%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%94%B1%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E3%80%82">http://books.gigatux.nl/mirror/kerneldevelopment/0672327201/ch12lev1sec7.html）这个数据结构由文件系统动态创建。</a></p>
<p>目录项被缓存在 <code class="java">
dentry_cache</code> 缓存中。例如，缓存条目会缓存 &#x2F;usr 、 &#x2F;usr&#x2F;local 等条目。如果多个进程通过硬连接访问相同的文件，他们的文件对象将指向此缓存中的相同条目。</p>
<p>最后，文件数据结构是代表着打开的文件，也代表着内存表示，它根据 open 系统调用创建。它支持 <strong>「read、write、sendfile、lock」</strong> 和其他在我们之前描述的系统调用中。</p>
<p>在 VFS 下实现的实际文件系统不需要在内部使用完全相同的抽象和操作。但是，它们必须在语义上实现与 VFS 对象指定的文件系统操作相同的文件系统操作。四个 VFS 对象中每个对象的操作数据结构的元素都是指向基础文件系统中功能的指针。</p>
<h4 id="Linux-Ext2-文件系统"><a href="#Linux-Ext2-文件系统" class="headerlink" title="Linux Ext2 文件系统"></a>Linux Ext2 文件系统</h4><p>现在我们一起看一下 Linux 中最流行的一个磁盘文件系统，那就是 <code class="java">
ext2</code> 。Linux 的第一个版本用于 <code class="java">
MINIX1</code> 文件系统，它的文件名大小被限制为最大 64 MB。MINIX 1 文件系统被永远的被它的扩展系统 ext 取代，因为 ext 允许更长的文件名和文件大小。由于 ext 的性能低下，ext 被其替代者 ext2 取代，ext2 目前仍在广泛使用。</p>
<p>一个 ext2 Linux 磁盘分区包含了一个文件系统，这个文件系统的布局如下所示</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFjc1lualdrdjJPQXhtbWJYM2w1Y3Vkc2djcWtEakZ3U2d3VDZRN3oxdnpaWWF1UHBZUTRXVUEvNjQw?x-oss-process=image/format,png">

<p>Boot 块也就是第 0 块不是让 Linux 使用的，而是用来加载和引导计算机启动代码的。在块 0 之后，磁盘分区被分成多个组，这些组与磁盘柱面边界所处的位置无关。</p>
<p>第一个块是 <code class="java">
超级块(superblock)</code>。它包含有关文件系统布局的信息，包括 i-node、磁盘块数量和以及空闲磁盘块列表的开始。下一个是 <code class="java">
组描述符(group descriptor)</code>，其中包含有关位图的位置，组中空闲块和 i-node 的数量以及组中的目录数量的信息。这些信息很重要，因为 ext2 会在磁盘上均匀分布目录。</p>
<p>图中的两个位图用来记录空闲块和空闲 i-node，这是从 MINIX 1文件系统继承的选择，大多数 UNIX 文件系统使用位图而不是空闲列表。每个位图的大小是一个块。如果一个块的大小是 1 KB，那么就限制了块组的数量是 8192 个块和 8192 个 i-node。块的大小是一个严格的限制，块组的数量不固定，在 4KB 的块中，块组的数量增大四倍。</p>
<p>在超级块之后分布的是 <code class="java">
i-node</code> 它们自己，i-node 取值范围是 1 - 某些最大值。每个 i-node 是 128 字节的 <code class="java">
long</code> ，这些字节恰好能够描述一个文件。i-node 包含了统计信息(包含了 <code class="java">
stat</code> 系统调用能获得的所有者信息，实际上 stat 就是从 i-node 中读取信息的)，以及足够的信息来查找保存文件数据的所有磁盘块。</p>
<p>在 i-node 之后的是 <code class="java">
数据块(data blocks)</code>。所有的文件和目录都保存在这。如果一个文件或者目录包含多个块，那么这些块在磁盘中的分布不一定是连续的，也有可能不连续。事实上，大文件块可能会被拆分成很多小块散布在整个磁盘上。</p>
<p>对应于目录的 i-node 分散在整个磁盘组上。如果有足够的空间，ext2 会把普通文件组织到与父目录相同的块组中，而把同一块上的数据文件组织成初始 <code class="java">
i-node</code> 节点。位图用来快速确定新文件系统数据的分配位置。在分配新的文件块时，ext2 也会给该文件预分配许多额外的数据块，这样可以减少将来向文件写入数据时产生的文件碎片。这种策略在整个磁盘上实现了文件系统的 <code class="java">
负载</code>，后续还有对文件碎片的排列和整理，而且性能也比较好。</p>
<p>为了达到访问的目的，需要首先使用 Linux 系统调用，例如 <code class="java">
open</code>，这个系统调用会确定打开文件的路径。路径分为两种，<code class="java">
相对路径</code> 和 <code class="java">
绝对路径</code>。如果使用相对路径，那么就会从当前目录开始查找，否则就会从根目录进行查找。</p>
<p>目录文件的文件名最高不能超过 255 个字符，它的分配如下图所示</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFNaWNRYjZwTFpDSk9BbXZ6MXVRSUUzSk45TkI3aEpZREZVMVh0cU41eGZyVTNzZlNIMVlpYnVxdy82NDA?x-oss-process=image/format,png">

<p>每一个目录都由整数个磁盘块组成，这样目录就可以整体的写入磁盘。在一个目录中，文件和子目录的目录项都是未经排序的，并且一个挨着一个。目录项不能跨越磁盘块，所以通常在每个磁盘块的尾部会有部分未使用的字节。</p>
<p>上图中每个目录项都由四个固定长度的属性和一个长度可变的属性组成。第一个属性是 <code class="java">
i-node</code> 节点数量，文件 first 的 i-node 编号是 19 ，文件 second 的编号是 42，目录 third 的 i-node 编号是 88。紧随其后的是 <code class="java">
rec_len</code> 域，表明目录项大小是多少字节，名称后面会有一些扩展，当名字以未知长度填充时，这个域被用来寻找下一个目录项，直至最后的未使用。这也是图中箭头的含义。紧随其后的是 <code class="java">
类型域</code>：F 表示的是文件，D 表示的是目录，最后是固定长度的文件名，上面的文件名的长度依次是 5、6、5，最后以文件名结束。</p>
<p>rec_len 域是如何扩展的呢？如下图所示</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFwaDlJVEpFemZ6UEVqTVdOWWdDcmljdFBTMGliOFd6akFLMUdJS1Q2SUYwWTlCaWFEOU96NUd0N3cvNjQw?x-oss-process=image/format,png">

<p>我们可以看到，中间的 <code class="java">
second</code> 被移除了，所以将其所在的域变为第一个目录项的填充。当然，这个填充可以作为后续的目录项。</p>
<p>由于目录是按照线性的顺序进行查找的，因此可能需要很长时间才能在大文件末尾找到目录项。因此，系统会为近期的访问目录维护一个缓存。这个缓存用文件名来查找，如果缓存命中，那么就会避免线程搜索这样昂贵的开销。组成路径的每个部分都在目录缓存中保存一个 <code class="java">
dentry</code> 对象，并且通过 i-node 找到后续的路径元素的目录项，直到找到真正的文件 i - node。</p>
<p>比如说要使用绝对路径来寻找一个文件，我们暂定这个路径是 <code class="java">
/usr/local/file</code>，那么需要经过如下几个步骤：</p>
<ul>
<li>首先，系统会确定根目录，它通常使用 2 号 i -node ，也就是索引 2 节点，因为索引节点 1 是 ext2 &#x2F;3&#x2F;4 文件系统上的<code class="java">
坏块</code>索引节点。系统会将一项放在 dentry 缓存中，以应对将来对根目录的查找。- 然后，在根目录中查找字符串 <code class="java">
usr</code>，得到 &#x2F;usr 目录的 i - node 节点号。&#x2F;usr 的 i - node 同样也进入 dentry 缓存。然后节点被取出，并从中解析出磁盘块，这样就可以读取 &#x2F;usr 目录并查找字符串 <code class="java">
local</code> 了。一旦找到这个目录项，目录 <code class="java">
/usr/local</code> 的 i - node 节点就可以从中获得。有了 &#x2F;usr&#x2F;local 的 i - node 节点号，就可以读取 i - node 并确定目录所在的磁盘块。最后，从 &#x2F;usr&#x2F;local 目录查找 file 并确定其 i - node 节点呢号。<br>如果文件存在，那么系统会提取 i - node 节点号并把它作为索引在 i - node 节点表中定位相应的 i - node 节点并装入内存。i - node 被存放在 i - node <code class="java">
节点表(i-node table)</code> 中，节点表是一个内核数据结构，它会持有当前打开文件和目录的 i - node 节点号。下面是一些 Linux 文件系统支持的 i - node 数据结构。</li>
</ul>
<p>|属性|字节|描述<br>|——<br>|Mode|2|文件属性、保护位、setuid 和 setgid 位<br>|Nlinks|2|指向 i - node 节点目录项的数目<br>|Uid|2|文件所有者的 UID<br>|Gid|2|文件所有者的 GID<br>|Size|4|文件字节大小<br>|Addr|60|12 个磁盘块以及后面 3 个间接块的地址<br>|Gen|1|每次重复使用 i - node 时增加的代号<br>|Atime|4|最近访问文件的时间<br>|Mtime|4|最近修改文件的时间<br>|Ctime|4|最近更改 i - node 的时间</p>
<p>现在我们来一起探讨一下文件读取过程，还记得 <code class="java">
read</code> 函数是如何调用的吗？</p>
<pre class="line-numbers language-java"><code class="language-java">
n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buffer<span class="token punctuation">,</span>nbytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>当内核接管后，它会从这三个参数以及内部表与用户有关的信息开始。内部表的其中一项是文件描述符数组。文件描述符数组用<code class="java">
文件描述符</code> 作为索引并为每一个打开文件保存一个表项。</p>
<p>文件是和 i - node 节点号相关的。那么如何通过一个文件描述符找到文件对应的 i - node 节点呢？</p>
<p>这里使用的一种设计思想是在文件描述符表和 i - node 节点表之间插入一个新的表，叫做 <code class="java">
打开文件描述符(open-file-description table)</code>。文件的读写位置会在打开文件描述符表中存在，如下图所示</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFjdWljaGNOYTU3QVdSMlkzV3hYSVptVkJBSHpHQ25Pa29GeVgxdVNsMnBXaDE4NE95MFV3WjdnLzY0MA?x-oss-process=image/format,png">

<p>我们使用 shell 、P1 和 P2 来描述一下父进程、子进程、子进程的关系。Shell 首先生成 P1，P1 的数据结构就是 Shell 的一个副本，因此两者都指向相同的打开文件描述符的表项。当 P1 运行完成后，Shell 的文件描述符仍会指向 P1 文件位置的打开文件描述。然后 Shell 生成了 P2，新的子进程自动继承文件的读写位置，甚至 P2 和 Shell 都不知道文件具体的读写位置。</p>
<p>上面描述的是父进程和子进程这两个 <code class="java">
相关</code> 进程，如果是一个不相关进程打开文件时，它将得到自己的打开文件描述符表项，以及自己的文件读写位置，这是我们需要的。</p>
<blockquote>
</blockquote>
<p>  ❝<br>  因此，打开文件描述符相当于是给相关进程提供同一个读写位置，而给不相关进程提供各自私有的位置。<br>  ❞</p>
<p>i - node 包含三个间接块的磁盘地址，它们每个指向磁盘块的地址所能够存储的大小不一样。</p>
<h4 id="Linux-Ext4-文件系统"><a href="#Linux-Ext4-文件系统" class="headerlink" title="Linux Ext4 文件系统"></a>Linux Ext4 文件系统</h4><p>为了防止由于系统崩溃和电源故障造成的数据丢失，ext2 系统必须在每个数据块创建之后立即将其写入到磁盘上，磁盘磁头寻道操作导致的延迟是无法让人忍受的。为了增强文件系统的健壮性，Linux 依靠<code class="java">
日志文件系统</code>，ext3 是一个日志文件系统，它在 ext2 文件系统的基础之上做了改进，ext4 也是 ext3 的改进，ext4 也是一个日志文件系统。ext4 改变了 ext3 的块寻址方案，从而支持更大的文件和更大的文件系统大小。下面我们就来描述一下 ext4 文件系统的特性。</p>
<p>具有记录的文件系统最基本的功能就是<code class="java">
记录日志</code>，这个日志记录了按照顺序描述所有文件系统的操作。通过顺序写出文件系统数据或元数据的更改，操作不受磁盘访问期间磁盘头移动的开销。最终，这个变更会写入并提交到合适的磁盘位置上。如果这个变更在提交到磁盘前文件系统宕机了，那么在重启期间，系统会检测到文件系统未正确卸载，那么就会遍历日志并应用日志的记录来对文件系统进行更改。</p>
<p>Ext4 文件系统被设计用来高度匹配 ext2 和 ext3 文件系统的，尽管 ext4 文件系统在内核数据结构和磁盘布局上都做了变更。尽管如此，一个文件系统能够从 ext2 文件系统上卸载后成功的挂载到 ext4 文件系统上，并提供合适的日志记录。</p>
<p>日志是作为循环缓冲区管理的文件。日志可以存储在与主文件系统相同或者不同的设备上。日志记录的读写操作会由单独的 <code class="java">
JBD(Journaling Block Device)</code> 来扮演。</p>
<p>JBD 中有三个主要的数据结构，分别是 <strong>「log record(日志记录)、原子操作和事务」</strong>。一个日志记录描述了一个低级别的文件系统操作，这个操作通常导致块内的变化。因为像是 <code class="java">
write</code> 这种系统调用会包含多个地方的改动 — i - node 节点，现有的文件块，新的文件块和空闲列表等。相关的日志记录会以原子性的方式分组。ext4 会通知系统调用进程的开始和结束，以此使 JBD 能够确保原子操作的记录都能被应用，或者一个也不被应用。最后，主要从效率方面考虑，JBD 会视原子操作的集合为事务。一个事务中的日志记录是连续存储的。只有在所有的变更一起应用到磁盘后，日志记录才能够被丢弃。</p>
<p>由于为每个磁盘写出日志的开销会很大，所以 ext4 可以配置为保留所有磁盘更改的日志，或者仅仅保留与文件系统元数据相关的日志更改。仅仅记录元数据可以减少系统开销，提升性能，但不能保证不会损坏文件数据。其他的几个日志系统维护着一系列元数据操作的日志，例如 SGI 的 XFS。</p>
<h4 id="x2F-proc-文件系统"><a href="#x2F-proc-文件系统" class="headerlink" title="&#x2F;proc 文件系统"></a>&#x2F;proc 文件系统</h4><p>另外一个 Linux 文件系统是 <code class="java">
/proc</code> (process) 文件系统</p>
<blockquote>
</blockquote>
<p>  ❝<br>  它的主要思想来源于贝尔实验室开发的第 8 版的 UNIX，后来被 BSD 和 System V 采用。<br>  ❞</p>
<p>然而，Linux 在一些方面上对这个想法进行了扩充。它的基本概念是为系统中的每个进程在 <code class="java">
/proc</code> 中创建一个目录。目录的名字就是进程 PID，以十进制数进行表示。例如，<code class="java">
/proc/1024</code> 就是一个进程号为 1024 的目录。在该目录下是进程信息相关的文件，比如进程的命令行、环境变量和信号掩码等。事实上，这些文件在磁盘上并不存在磁盘中。当需要这些信息的时候，系统会按需从进程中读取，并以标准格式返回给用户。</p>
<p>许多 Linux 扩展与 <code class="java">
/proc</code> 中的其他文件和目录有关。它们包含各种各样的关于 CPU、磁盘分区、设备、中断向量、内核计数器、文件系统、已加载模块等信息。非特权用户可以读取很多这样的信息，于是就可以通过一种安全的方式了解系统情况。</p>
<h3 id="NFS-网络文件系统"><a href="#NFS-网络文件系统" class="headerlink" title="NFS 网络文件系统"></a>NFS 网络文件系统</h3><p>从一开始，网络就在 Linux 中扮演了很重要的作用。下面我们会探讨一下 <code class="java">
NFS(Network File System)</code> 网络文件系统，它在现代 Linux 操作系统的作用是将不同计算机上的不同文件系统链接成一个逻辑整体。</p>
<h4 id="NFS-架构"><a href="#NFS-架构" class="headerlink" title="NFS 架构"></a>NFS 架构</h4><p>NFS 最基本的思想是允许任意选定的一些<code class="java">
客户端</code>和<code class="java">
服务器</code>共享一个公共文件系统。在许多情况下，所有的客户端和服务器都会在同一个 <code class="java">
LAN(Local Area Network)</code>  局域网内共享，但是这并不是必须的。也可能是下面这样的情况：如果客户端和服务器距离较远，那么它们也可以在广域网上运行。客户端可以是服务器，服务器可以是客户端，但是为了简单起见，我们说的客户端就是消费服务，而服务器就是提供服务的角度来聊。</p>
<p>每一个 NFS 服务都会导出一个或者多个目录供远程客户端访问。当一个目录可用时，它的所有子目录也可用。因此，通常整个目录树都会作为一个整体导出。服务器导出的目录列表会用一个文件来维护，这个文件是 <code class="java">
/etc/exports</code>，当服务器启动后，这些目录可以自动的被导出。客户端通过挂载这些导出的目录来访问它们。当一个客户端挂载了一个远程目录，这个目录就成为客户端目录层次的一部分，如下图所示。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFLRHMyWm5ibWNYMkJQUndVMDBpYVd6Qm9zVlpVT3kxNlJMS0tOdHB6dGhKdUhRWmZtRklxeUVnLzY0MA?x-oss-process=image/format,png">

<p>在这个示例中，一号客户机挂载到服务器的 bin 目录下，因此它现在可以使用 shell 访问 &#x2F;bin&#x2F;cat 或者其他任何一个目录。同样，客户机 1 也可以挂载到 二号服务器上从而访问 &#x2F;usr&#x2F;local&#x2F;projects&#x2F;proj1 或者其他目录。二号客户机同样可以挂载到二号服务器上，访问路径是 &#x2F;mnt&#x2F;projects&#x2F;proj2。</p>
<p>从上面可以看到，由于不同的客户端将文件挂载到各自目录树的不同位置，同一个文件在不同的客户端有不同的访问路径和不同的名字。挂载点一般通常在客户端本地，服务器不知道任何一个挂载点的存在。</p>
<h4 id="NFS-协议"><a href="#NFS-协议" class="headerlink" title="NFS 协议"></a>NFS 协议</h4><p>由于 NFS 的协议之一是支持 <code class="java">
异构</code> 系统，客户端和服务器可能在不同的硬件上运行不同的操作系统，因此有必要在服务器和客户端之间进行接口定义。这样才能让任何写一个新客户端能够和现有的服务器一起正常工作，反之亦然。</p>
<p>NFS 就通过定义两个客户端 - 服务器协议从而实现了这个目标。协议就是客户端发送给服务器的一连串的请求，以及服务器发送回客户端的相应答复。</p>
<p>第一个 NFS 协议是处理挂载。客户端可以向服务器发送路径名并且请求服务器是否能够将服务器的目录挂载到自己目录层次上。因为服务器不关心挂载到哪里，因此请求不会包含挂载地址。如果路径名是合法的并且指定的目录已经被导出，那么服务器会将文件 <code class="java">
句柄</code> 返回给客户端。</p>
<blockquote>
</blockquote>
<p>  ❝<br>  文件句柄包含唯一标识文件系统类型，磁盘，目录的i节点号和安全性信息的字段。<br>  ❞</p>
<p>随后调用读取和写入已安装目录或其任何子目录中的文件，都将使用文件句柄。</p>
<p>当 Linux 启动时会在多用户之前运行 shell 脚本 &#x2F;etc&#x2F;rc 。可以将挂载远程文件系统的命令写入该脚本中，这样就可以在允许用户登陆之前自动挂载必要的远程文件系统。大部分 Linux 版本是支持<code class="java">
自动挂载</code>的。这个特性会支持将远程目录和本地目录进行关联。</p>
<p>相对于手动挂载到 &#x2F;etc&#x2F;rc 目录下，自动挂载具有以下优势</p>
<ul>
<li>如果列出的 &#x2F;etc&#x2F;rc 目录下出现了某种故障，那么客户端将无法启动，或者启动会很困难、延迟或者伴随一些出错信息，如果客户根本不需要这个服务器，那么手动做了这些工作就白费了。- 允许客户端并行的尝试一组服务器，可以实现一定程度的容错率，并且性能也可以得到提高。<br>另一方面，我们默认在自动挂载时所有可选的文件系统都是相同的。由于 NFS 不提供对文件或目录复制的支持，用户需要自己确保这些所有的文件系统都是相同的。因此，大部分的自动挂载都只应用于二进制文件和很少改动的只读的文件系统。</li>
</ul>
<p>第二个 NFS 协议是为文件和目录的访问而设计的。客户端能够通过向服务器发送消息来操作目录和读写文件。客户端也可以访问文件属性，比如文件模式、大小、上次修改时间。NFS 支持大多数的 Linux 系统调用，但是 open 和 close 系统调用却不支持。</p>
<blockquote>
</blockquote>
<p>  ❝<br>  不支持 open 和 close 并不是一种疏忽，而是一种刻意的设计，完全没有必要在读一个文件之前对其进行打开，也没有必要在读完时对其进行关闭。<br>  ❞</p>
<p>NFS 使用了标准的 UNIX 保护机制，使用 <code class="java">
rwx</code> 位来标示<code class="java">
所有者(owner)</code>、<code class="java">
组(groups)</code>、<code class="java">
其他用户</code> 。最初，每个请求消息都会携带调用者的 groupId 和 userId，NFS 会对其进行验证。事实上，它会信任客户端不会发生欺骗行为。可以使用公钥密码来创建一个安全密钥，在每次请求和应答中使用它验证客户端和服务器。</p>
<h4 id="NFS-实现"><a href="#NFS-实现" class="headerlink" title="NFS 实现"></a>NFS 实现</h4><p>即使客户端和服务器的代码实现是独立于 NFS 协议的，大部分的 Linux 系统会使用一个下图的三层实现，顶层是系统调用层，系统调用层能够处理 open 、 read 、 close 这类的系统调用。在解析和参数检查结束后调用第二层，<code class="java">
虚拟文件系统 (VFS)</code> 层。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFTWjVvV1RYSnE3WFZVT01DZ0xpYjZDR3psSWhWR0NJeGFFNDhNaWFLUGtrN3ZCTmZmZEhYNEZFZy82NDA?x-oss-process=image/format,png">

<p>VFS 层的任务是维护一个表，每个已经打开的文件都在表中有一个表项。VFS 层为每一个打开的文件维护着一个<code class="java">
虚拟i节点</code>，简称为 v - node。v 节点用来说明文件是本地文件还是远程文件。如果是远程文件的话，那么 v - node 会提供足够的信息使客户端能够访问它们。对于本地文件，会记录其所在的文件系统和文件的 i-node ，因为现代操作系统能够支持多文件系统。虽然 VFS 是为了支持 NFS 而设计的，但是现代操作系统都会使用 VFS，而不管有没有 NFS。</p>
<h2 id="Linux-IO"><a href="#Linux-IO" class="headerlink" title="Linux IO"></a>Linux IO</h2><p>我们之前了解过了 Linux 的进程和线程、Linux 内存管理，那么下面我们就来认识一下 Linux 中的 I&#x2F;O 管理。</p>
<p>Linux 系统和其他 UNIX 系统一样，IO 管理比较直接和简洁。所有 IO 设备都被当作<code class="java">
文件</code>，通过在系统内部使用相同的 read 和 write 一样进行读写。</p>
<h3 id="Linux-IO-基本概念"><a href="#Linux-IO-基本概念" class="headerlink" title="Linux IO 基本概念"></a>Linux IO 基本概念</h3><p>Linux 中也有磁盘、打印机、网络等 I&#x2F;O 设备，Linux 把这些设备当作一种 <code class="java">
特殊文件</code> 整合到文件系统中，一般通常位于 <code class="java">
/dev</code> 目录下。可以使用与普通文件相同的方式来对待这些特殊文件。</p>
<p>特殊文件一般分为两种：</p>
<p>块特殊文件是一个能存储<code class="java">
固定大小块</code>信息的设备，它支持<strong>「以固定大小的块，扇区或群集读取和（可选）写入数据」</strong>。每个块都有自己的<code class="java">
物理地址</code>。通常块的大小在 512 - 65536 之间。所有传输的信息都会以<code class="java">
连续</code>的块为单位。块设备的基本特征是每个块都较为对立，能够独立的进行读写。常见的块设备有 <strong>「硬盘、蓝光光盘、USB 盘」</strong>与字符设备相比，块设备通常需要较少的引脚。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFoSzBVOGtpYzc2MGNWSFdJUHVoMFhnaWM1aWJpYkxUd2JqdWwzbWVoelZVSEQ2TmljYTNlZnNuaWJjTHcvNjQw?x-oss-process=image/format,png">

<p>块特殊文件的缺点基于给定固态存储器的块设备比基于相同类型的存储器的字节寻址要慢一些，因为必须在块的开头开始读取或写入。所以，要读取该块的任何部分，必须寻找到该块的开始，读取整个块，如果不使用该块，则将其丢弃。要写入块的一部分，必须寻找到块的开始，将整个块读入内存，修改数据，再次寻找到块的开头处，然后将整个块写回设备。</p>
<p>另一类 I&#x2F;O 设备是<code class="java">
字符特殊文件</code>。字符设备以<code class="java">
字符</code>为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。常见的字符设备有 <strong>「打印机、网络设备、鼠标、以及大多数与磁盘不同的设备」</strong>。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFYc252alRpYXlHdG5IVHFveUVaVzBjdWhzYm9rWDZhVk9MOXVtb0h1WXdmUG9MRFlIbkFVRjZRLzY0MA?x-oss-process=image/format,png">

<p>每个设备特殊文件都会和 <code class="java">
设备驱动</code> 相关联。每个驱动程序都通过一个 <code class="java">
主设备号</code> 来标识。如果一个驱动支持多个设备的话，此时会在主设备的后面新加一个 <code class="java">
次设备号</code> 来标识。主设备号和次设备号共同确定了唯一的驱动设备。</p>
<p>我们知道，在计算机系统中，CPU 并不直接和设备打交道，它们中间有一个叫作 <code class="java">
设备控制器（Device Control Unit）</code>的组件，例如硬盘有磁盘控制器、USB 有 USB 控制器、显示器有视频控制器等。这些控制器就像代理商一样，它们知道如何应对硬盘、鼠标、键盘、显示器的行为。</p>
<p>绝大多数字符特殊文件都不能随机访问，因为他们需要使用和块特殊文件不同的方式来控制。比如，你在键盘上输入了一些字符，但是你发现输错了一个，这时有一些人喜欢使用 <code class="java">
backspace</code> 来删除，有人喜欢用 <code class="java">
del</code> 来删除。为了中断正在运行的设备，一些系统使用 <code class="java">
ctrl-u</code> 来结束，但是现在一般使用 <code class="java">
ctrl-c</code> 来结束。</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>I&#x2F;O 的另外一个概念是<code class="java">
网络</code>， 也是由 UNIX 引入，网络中一个很关键的概念就是 <code class="java">
套接字(socket)</code>。套接字允许用户连接到网络，正如邮筒允许用户连接到邮政系统，套接字的示意图如下</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlF3OGgxZmhDaWFmUGlhVnVpYVRzNDlpYUxVTnVtaWNseERjTUFMUmVvS0VaRE0yaWNYZUdNaDh1Qm9OaFEvNjQw?x-oss-process=image/format,png">

<p>套接字的位置如上图所示，套接字可以动态创建和销毁。成功创建一个套接字后，系统会返回一个<code class="java">
文件描述符(file descriptor)</code>，在后面的创建链接、读数据、写数据、解除连接时都需要使用到这个文件描述符。每个套接字都支持一种特定类型的网络类型，在创建时指定。一般最常用的几种</p>
<ul>
<li>可靠的面向连接的字节流- 可靠的面向连接的数据包- 不可靠的数据包传输<br>可靠的面向连接的字节流会使用<code class="java">
管道</code> 在两台机器之间建立连接。能够保证字节从一台机器按照顺序到达另一台机器，系统能够保证所有字节都能到达。</li>
</ul>
<p>除了数据包之间的分界之外，第二种类型和第一种类型是类似的。如果发送了 3 次写操作，那么使用第一种方式的接受者会直接接收到所有字节；第二种方式的接受者会分 3 次接受所有字节。除此之外，用户还可以使用第三种即不可靠的数据包来传输，使用这种传输方式的优点在于高性能，有的时候它比可靠性更加重要，比如在流媒体中，性能就尤其重要。</p>
<p>以上涉及两种形式的传输协议，即 <code class="java">
TCP</code> 和 <code class="java">
UDP</code>，TCP 是 <code class="java">
传输控制协议</code>，它能够传输可靠的字节流。<code class="java">
UDP</code> 是 <code class="java">
用户数据报协议</code>，它只能够传输不可靠的字节流。它们都属于 TCP&#x2F;IP 协议簇中的协议，下面是网络协议分层</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlF4T3pHTG4zRE5BSHFjeGVFMjU5ZjZQaWJqeFBWMEw2VUg1cjdwNHB1Z2liT1VpYXdyVEx3aWNwNTdBLzY0MA?x-oss-process=image/format,png">

<p>可以看到，TCP 、UDP 都位于网络层上，可见它们都把 IP 协议 即 <code class="java">
互联网协议</code> 作为基础。</p>
<p>一旦套接字在源计算机和目的计算机建立成功，那么两个计算机之间就可以建立一个链接。通信一方在本地套接字上使用 <code class="java">
listen</code> 系统调用，它就会创建一个缓冲区，然后阻塞直到数据到来。另一方使用 <code class="java">
connect</code> 系统调用，如果另一方接受 connect 系统调用后，则系统会在两个套接字之间建立连接。</p>
<p>socket 连接建立成功后就像是一个管道，一个进程可以使用本地套接字的文件描述符从中读写数据，当连接不再需要的时候使用 <code class="java">
close</code> 系统调用来关闭。</p>
<h3 id="Linux-I-x2F-O-系统调用"><a href="#Linux-I-x2F-O-系统调用" class="headerlink" title="Linux I&#x2F;O 系统调用"></a>Linux I&#x2F;O 系统调用</h3><p>Linux 系统中的每个 I&#x2F;O 设备都有一个<code class="java">
特殊文件(special file)</code>与之关联，什么是特殊文件呢？</p>
<blockquote>
</blockquote>
<p>  ❝<br>  在操作系统中，特殊文件是一种在文件系统中与硬件设备相关联的文件。特殊文件也被称为 <code class="java">
设备文件(device file)</code>。特殊文件的目的是将设备作为文件系统中的文件进行公开。特殊文件为硬件设备提供了借口，用于文件 I&#x2F;O 的工具可以进行访问。因为设备有两种类型，同样特殊文件也有两种，即字符特殊文件和块特殊文件<br>  ❞</p>
<p>对于大部分 I&#x2F;O 操作来说，只用合适的文件就可以完成，并不需要特殊的系统调用。然后，有时需要一些设备专用的处理。在 POSIX 之前，大多数 UNIX 系统会有一个叫做 <code class="java">
ioctl</code> 的系统调用，它用于执行大量的系统调用。随着时间的发展，POSIX 对其进行了整理，把 ioctl 的功能划分为面向终端设备的独立功能调用，现在已经变成独立的系统调用了。</p>
<p>下面是几个管理终端的系统调用</p>
<th width="274">系统调用</th><th width="220">描述</th>
|------
<td width="175">tcgetattr</td><td width="220">获取属性</td>
<td width="175">tcsetattr</td><td width="220">设置属性</td>
<td width="175">cfgetispeed</td><td width="220">获取输入速率</td>
<td width="175">cfgetospeed</td><td width="220">获取输出速率</td>
<td width="175">cfsetispeed</td><td width="220">设置输入速率</td>
<td width="175">cfsetospeed</td><td width="220">设置输出速率</td>



<h3 id="Linux-IO-实现"><a href="#Linux-IO-实现" class="headerlink" title="Linux IO 实现"></a>Linux IO 实现</h3><p>Linux 中的 IO 是通过一系列设备驱动实现的，每个设备类型对应一个设备驱动。设备驱动为操作系统和硬件分别预留接口，通过设备驱动来屏蔽操作系统和硬件的差异。</p>
<p>当用户访问一个特殊的文件时，由文件系统提供此特殊文件的主设备号和次设备号，并判断它是一个块特殊文件还是字符特殊文件。主设备号用于标识字符设备还是块设备，次设备号用于参数传递。</p>
<p>每个<code class="java">
驱动程序</code> 都有两部分：这两部分都是属于 Linux 内核，也都运行在内核态下。上半部分运行在调用者上下文并且与 Linux 其他部分交互。下半部分运行在内核上下文并且与设备进行交互。驱动程序可以调用内存分配、定时器管理、DMA 控制等内核过程。可被调用的内核功能都位于 <code class="java">
驱动程序 - 内核接口</code> 的文档中。</p>
<p>I&#x2F;O 实现指的就是对字符设备和块设备的实现</p>
<h4 id="块设备实现"><a href="#块设备实现" class="headerlink" title="块设备实现"></a>块设备实现</h4><p>系统中处理块特殊文件 I&#x2F;O 部分的目标是为了使传输次数尽可能的小。为了实现这个目标，Linux 系统在磁盘驱动程序和文件系统之间设置了一个 <code class="java">
高速缓存(cache)</code> ，如下图所示</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlFMSG9pYVVVUnlmVUNMS3k0YzF4cTFpYkNaZlpEbm1iWnlacWVsV3Z4M3NUTEhYOUxVR2lhUmZWTXcvNjQw?x-oss-process=image/format,png">

<p>在 Linux 内核 2.2 之前，Linux 系统维护着两个缓存：<code class="java">
页面缓存(page cache)</code> 和 <code class="java">
缓冲区缓存(buffer cache)</code>，因此，存储在一个磁盘块中的文件可能会在两个缓存中。2.2 版本以后 Linux 内核只有一个统一的缓存一个 <code class="java">
通用数据块层(generic block layer)</code> 把这些融合在一起，实现了磁盘、数据块、缓冲区和数据页之间必要的转换。那么什么是通用数据块层？</p>
<blockquote>
</blockquote>
<p>  ❝<br>  通用数据块层是一个内核的组成部分，用于处理对系统中所有块设备的请求。通用数据块主要有以下几个功能<br>  将数据缓冲区放在内存高位处，当 CPU 访问数据时，页面才会映射到内核线性地址中，并且此后取消映射<br>  实现 <code class="java">
零拷贝</code>机制，磁盘数据可以直接放入用户模式的地址空间，而无需先复制到内核内存中<br>  管理磁盘卷，会把不同块设备上的多个磁盘分区视为一个分区。<br>  利用最新的磁盘控制器的高级功能，例如 DMA 等。<br>  ❞</p>
<p>cache 是提升性能的利器，不管以什么样的目的需要一个数据块，都会先从 cache 中查找，如果找到直接返回，避免一次磁盘访问，能够极大的提升系统性能。</p>
<p>如果页面 cache 中没有这个块，操作系统就会把页面从磁盘中调入内存，然后读入 cache 进行缓存。</p>
<p>cache 除了支持读操作外，也支持写操作，一个程序要写回一个块，首先把它写到 cache 中，而不是直接写入到磁盘中，等到磁盘中缓存达到一定数量值时再被写入到 cache 中。</p>
<p>Linux 系统中使用 <code class="java">
IO 调度器</code> 来保证减少磁头的反复移动从而减少损失。I&#x2F;O 调度器的作用是对块设备的读写操作进行排序，对读写请求进行合并。Linux 有许多调度器的变体，从而满足不同的工作需要。最基本的 Linux 调度器是基于传统的 <code class="java">
Linux 电梯调度器(Linux elevator scheduler)</code>。Linux 电梯调度器的主要工作流程就是按照磁盘扇区的地址排序并存储在一个<code class="java">
双向链表</code> 中。新的请求将会以链表的形式插入。这种方法可以有效的防止磁头重复移动。因为电梯调度器会容易产生饥饿现象。因此，Linux 在原基础上进行了修改，维护了两个链表，在 <code class="java">
最后日期(deadline)</code> 内维护了排序后的读写操作。默认的读操作耗时 0.5s，默认写操作耗时 5s。如果在最后期限内等待时间最长的链表没有获得服务，那么它将优先获得服务。</p>
<h4 id="字符设备实现"><a href="#字符设备实现" class="headerlink" title="字符设备实现"></a>字符设备实现</h4><p>和字符设备的交互是比较简单的。由于字符设备会产生并使用字符流、字节数据，因此对随机访问的支持意义不大。一个例外是使用 <code class="java">
行规则(line disciplines)</code>。一个行规可以和终端设备相关联，使用 <code class="java">
tty_struct</code> 结构来表示，它表示与终端设备交换数据的解释器，当然这也属于内核的一部分。例如：行规可以对行进行编辑，映射回车为换行等一系列其他操作。</p>
<blockquote>
</blockquote>
<p>  ❝<br>  什么是行规则？<br>  行规是某些类 UNIX 系统中的一层，终端子系统通常由三层组成：上层提供字符设备接口，下层硬件驱动程序与硬件或伪终端进行交互，中层规则用于实现终端设备共有的行为。<br>  ❞</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BM2liY2ljMVhlMGlhU2ljTGJySmtFYWQ5MFJqTVVuT09JYlE5MmsyZUlZTUVpYUpyRFZUVVRtSTFsaWJNSXViYmNlUU1scmljVjBuaGgwOTFJMDlkcE1XNHJrQmcvNjQw?x-oss-process=image/format,png">

<h4 id="网络设备实现"><a href="#网络设备实现" class="headerlink" title="网络设备实现"></a>网络设备实现</h4><p>网络设备的交互是不一样的，虽然 <code class="java">
网络设备(network devices)</code> 也会产生字符流，因为它们的<code class="java">
异步(asynchronous)</code> 特性是他们不易与其他字符设备在同一接口下集成。网络设备驱动程序会产生很多数据包，经由网络协议到达用户应用程序中。</p>
<h3 id="Linux-中的模块"><a href="#Linux-中的模块" class="headerlink" title="Linux 中的模块"></a>Linux 中的模块</h3><p>UNIX 设备驱动程序是被<code class="java">
静态加载</code>到内核中的。因此，只要系统启动后，设备驱动程序都会被加载到内存中。随着个人电脑 Linux 的出现，这种静态链接完成后会使用一段时间的模式被打破。相对于小型机上的 I&#x2F;O 设备，PC 上可用的 I&#x2F;O 设备有了数量级的增长。绝大多数用户没有能力去添加一个新的应用程序、更新设备驱动、重新连接内核，然后进行安装。</p>
<p>Linux 为了解决这个问题，引入了 <code class="java">
可加载(loadable module)</code> 机制。可加载是在系统运行时添加到内核中的代码块。</p>
<p>当一个模块被加载到内核时，会发生下面几件事情：第一，在加载的过程中，模块会被动态的重新部署。第二，系统会检查程序程序所需的资源是否可用。如果可用，则把这些资源标记为正在使用。第三步，设置所需的中断向量。第四，更新驱动转换表使其能够处理新的主设备类型。最后再来运行设备驱动程序。</p>
<p>在完成上述工作后，驱动程序就会安装完成，其他现代 UNIX 系统也支持可加载机制。</p>
<h2 id="Linux-安全"><a href="#Linux-安全" class="headerlink" title="Linux 安全"></a>Linux 安全</h2><p>Linux 作为 MINIX 和 UNIX 的衍生操作系统，从一开始就是一个<code class="java">
多用户</code>系统。这意味着 Linux 从早期开始就建立了安全和信息访问控制机制。下面我们主要探讨的就是 Linux 安全性的一些内容</p>
<h3 id="Linux-安全基本概念"><a href="#Linux-安全基本概念" class="headerlink" title="Linux 安全基本概念"></a>Linux 安全基本概念</h3><p>一个 Linux 系统的用户群里由一系列注册用户组成，他们每一个都有一个唯一的 UID (User ID)。一个 UID 是一个位于 0 到 65535 之间的整数。文件（进程或者是其他资源）都标记了它的所有者的 UID。默认情况下，文件的所有者是创建文件的人，文件的所有者是创建文件的用户。</p>
<p>用户可以被分成许多组，每个组都会由一个 16 位的整数标记，这个组叫做 <code class="java">
GID(组 ID)</code>。给用户分组是手动完成的，它由系统管理员执行，分组就是在数据库中添加一条记录指明哪个用户属于哪个组。一个用户可以属于不同组。</p>
<p>Linux 中的基本安全机制比较容易理解，每个进程都会记录它所有者的 UID 和 GID。当文件创建后，它会获取创建进程的 UID 和 GID。当一个文件被创建时，它的 UID 和 GID 就会被标记为进程的 UID 和 GID。这个文件同时会获取由该进程决定的一些权限。这些权限会指定所有者、所有者所在组的其他用户及其他用户对文件具有什么样的访问权限。对于这三类用户而言，潜在的访问权限是 <strong>「读、写和执行」</strong>，分别由 r、w 和 x 标记。当然，执行文件的权限仅当文件时可逆二进制程序时才有意义。试图执行一个拥有执行权限的非可执行文件，系统会报错。</p>
<p><strong>「Linux 用户分为三种」</strong></p>
<ul>
<li><code class="java">
root（超级管理员）</code>，它的 UID 为 0，这个用户有极大的权限，可以直接无视很多的限制 ，包括读写执行的权限。- <code class="java">
系统用户</code>，UID 为 1～499。- <code class="java">
普通用户</code>，UID 范围一般是 500～65534。这类用户的权限会受到基本权限的限制，也会受到来自管理员的限制。不过要注意 nobody 这个特殊的帐号，UID 为 65534，这个用户的权限会进一步的受到限制，一般用于实现来宾帐号。<br>Linux 中的每类用户由 3 个比特为来标记，所以 9 个比特位就能够表示所有的权限。</li>
</ul>
<p>下面来看一下一些基本的用户和权限例子</p>
<p>|二进制|标记|准许的文件访问权限<br>|——<br>|111000000|rwx——|所有者可读、写和执行<br>|111111000|rwxrwx—|所有者和组可以读、写和执行<br>|111111111|rwxrwxrwx|所有人可以读、写和执行<br>|000000000|———|任何人不拥有任何权限<br>|000000111|——rwx|只有组以外的其他用户拥有所有权<br>|110100100|rw-r–r–|所有者可以读和写，其他人可以读<br>|110100100|rw-r—–|所有者可以读和写，组可以读</p>
<p>我们上面提到，UID 为 0 的是一个特殊用户，称为 <code class="java">
超级用户(或者根用户)</code>。超级用户能够读和写系统中的任何文件，不管这个文件由谁所有，也不管这个文件的保护模式如何。UID 为 0 的进程还具有少数调用受保护系统调用的权限，而普通用户是不可能有这些功能的。通常情况下，只有系统管理员知道超级用户的密码。</p>
<p>在 Linux 系统下，目录也是一种文件，并且具有和普通文件一样的保护模式。不同的是，目录的 x 比特位表示查找权限而不是执行权限。因此，如果一个目录的保护模式是 <code class="java">
rwxr-xr-x</code>，那么它允许所有者读、写和查找目录，而其他人只可以读和查找，而不允许从中添加或者删除目录中的文件。</p>
<p>与 I&#x2F;O 有关的特殊文件拥有和普通文件一样的保护位。这种机制可以用来限制对 I&#x2F;O 设备的访问权限。举个例子，打印机是特殊文件，它的目录是 <code class="java">
/dev/lp</code>，它可以被根用户或者一个叫守护进程的特殊用户拥有，具有保护模式 rw——-，从而阻止其他所有人对打印机的访问。毕竟每个人都使用打印机的话会发生混乱。</p>
<p>当然，如果 &#x2F;dev&#x2F;lp 的保护模式是 rw——-，那就意味着其他任何人都不能使用打印机。</p>
<p>这个问题通过增加一个保护位 <code class="java">
SETUID</code> 到之前的 9 个比特位来解决。当一个进程的 SETUID 位打开，它的 <code class="java">
有效 UID</code> 将变成相应可执行文件的所有者 UID，而不是当前使用该进程的用户的 UID。将访问打印机的程序设置为守护进程所有，同时打开 SETUID 位，这样任何用户都可以执行此程序，而且拥有守护进程的权限。</p>
<p>除了 SETUID 之外，还有一个 SETGID 位，SETGID 的工作原理和 SETUID 类似。但是这个位一般很不常用。</p>
<h3 id="Linux-安全相关的系统调用"><a href="#Linux-安全相关的系统调用" class="headerlink" title="Linux 安全相关的系统调用"></a>Linux 安全相关的系统调用</h3><p>Linux 中关于安全的系统调用不是很多，只有几个，如下列表所示</p>
<th width="188">系统调用</th><th width="321">描述</th>
|------
<td width="103">chmod</td><td width="321">改变文件的保护模式</td>
<td width="103">access</td><td width="321">使用真实的 UID 和 GID 测试访问权限</td>
<td width="103">chown</td><td width="321">改变所有者和组</td>
<td width="103">setuid</td><td width="321">设置 UID</td>
<td width="103">setgid</td><td width="321">设置 GID</td>
<td width="103">getuid</td><td width="321">获取真实的 UID</td>
<td width="103">getgid</td><td width="321">获取真实的 GID</td>
<td width="103">geteuid</td><td width="321">获取有效的 UID</td>
<td width="103">getegid</td><td width="321">获取有效的 GID</td>



<p>我们在日常开发中用到最多的就是 <code class="java">
chmod</code>了，没想到我们日常开发过程中也能用到系统调用啊，chmod 之前我们一直认为是改变权限，现在专业一点是改变文件的保护模式。它的具体函数如下</p>
<pre class="line-numbers language-java"><code class="language-java">
s <span class="token operator">=</span> <span class="token function">chmod</span><span class="token punctuation">(</span><span class="token string">"路径名"</span><span class="token punctuation">,</span><span class="token string">"值"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>例如</p>
<pre class="line-numbers language-java"><code class="language-java">
s <span class="token operator">=</span> <span class="token function">chmod</span><span class="token punctuation">(</span><span class="token string">"/usr/local/cxuan"</span><span class="token punctuation">,</span><span class="token number">777</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>他就是会把 <code class="java">
/usr/local/cxuan</code> 这个路径的保护模式改为 rwxrwxrwx，任何组和人都可以操作这个路径。只有该文件的所有者和超级用户才有权利更改保护模式。</p>
<p><code class="java">
access</code> 系统调用用来检验实际的 UID 和 GID 对某文件是否拥有特定的权限。下面就是四个 getxxx 的系统调用，这些用来获取 uid 和 gid 的。</p>
<blockquote>
</blockquote>
<p>  ❝<br>  注意：其中的 chown、setuid 和 setgid 是超级用户才能使用，用来改变所有者进程的 UID 和 GID。<br>  ❞</p>
<h3 id="Linux-安全实现"><a href="#Linux-安全实现" class="headerlink" title="Linux 安全实现"></a>Linux 安全实现</h3><p>当用户登录时，登录程序，也被称为 <code class="java">
login</code>，会要求输入用户名和密码。它会对密码进行哈希处理，然后在 <code class="java">
/etc/passwd</code> 中进行查找，看看是否有匹配的项。使用哈希的原因是防止密码在系统中以非加密的方式存在。如果密码正确，登录程序会在 &#x2F;etc&#x2F;passwd 中读取用户选择的 shell 程序的名称，有可能是 <code class="java">
bash</code>，有可能是 <code class="java">
shell</code> 或者其他的 <code class="java">
csh</code> 或 <code class="java">
ksh</code>。然后登录程序使用 setuid 和 setgid 这两个系统调用来把自己的 UID 和 GID 变为用户的 UID 和 GID，然后它打开键盘作为标准输入、标准输入的文件描述符是 0 ，屏幕作为标准输出，文件描述符是 1 ，屏幕也作为标准错误输出，文件描述符为 2。最后，执行用户选择的 shell 程序，终止。</p>
<p>当任何进程想要打开一个文件，系统首先将文件的 i - node 所记录的保护位与用户有效 UID 和 有效 GID 进行对比，来检查访问是否允许。如果访问允许，就打开文件并返回文件描述符；否则不打开文件，返回 - 1。</p>
<p>Linux 安全模型和实现在本质上与大多数传统的 UNIX 系统相同。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇文章从 Linux 进程线程、内存管理、文件系统、IO 管理和安全来为你呈现了一幅 Linux 蓝图，文中涉及大量的系统调用和解释，是你了解 Linux 操作系统需要仔细研读的一篇文章。</p>
<p>希望这篇文章能带你了解更多关于 Linux 的基本知识，如果对你有帮助，希望小伙伴们不要吝啬的为我</p>
<h4 id="原创电子书"><a href="#原创电子书" class="headerlink" title="原创电子书"></a>原创电子书</h4><p>历时<strong>整整一年</strong>总结的 <strong>Java 面试 + Java 后端技术学习指南</strong>，这是本人这几年及校招的总结，各种高频面试题已经全部进行总结，按照章节复习即可，已经拿到了大厂offer。</p>
<h4 id="原创思维导图"><a href="#原创思维导图" class="headerlink" title="原创思维导图"></a>原创思维导图</h4><p>扫码或者微信搜 <strong>程序员的技术圈子</strong> 回复 <strong>面试</strong> 领取原创电子书和思维导图。</p>
<p>原文地址：<a target="_blank" rel="noopener" href="https://sihai.blog.csdn.net/article/details/109466084">https://sihai.blog.csdn.net/article/details/109466084</a></p>

                </div>
                <!-- 欧阳思海，modify，2020.05.01-->
<!-- 文章详情详情页面的头部广告位置信息 -->
<div id="post-head-panel">
    
    <a href="https://github.com/OUYANGSIHAI/JavaInterview" style="font-size: 18px;" target="_blank">
        <img src="/icons/hot.gif">
        本人花费半年的时间总结的《Java面试指南》已拿腾讯等大厂offer，已开源在github ，欢迎star！
    </a>
    
    
</div>
<br />



<blockquote>
    
            <p>本文GitHub <a href="https://github.com/OUYANGSIHAI/JavaInterview" target="_blank">https://github.com/OUYANGSIHAI/JavaInterview</a> 已收录，这是我花了6个月总结的<b>一线大厂Java面试</b>总结，本人已拿大厂offer，欢迎star</p>
    
    <p>原文链接：blog.ouyangsihai.cn &gt;&gt; <a href="/5w-zi-de-linux-zhi-shi-zong-jie.html" target="_blank">5W 字的 Linux 知识总结</a></p>
</blockquote>
                <hr />

                
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">多少都是对我的认可</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="http://image.ouyangsihai.cn/FpbhsOuf3Ar9vY34B97Y2qQ7LVGe" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="http://image.ouyangsihai.cn/FgYlMzms68PH73PWpZBwPfbLTAws" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
                

                <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

                

                
                <div class="reprint1">
                    <p>
                        <span class="reprint1-tip">
                            <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;转载请注明:
                        </span>
                        <a href="https://blog.ouyangsihai.cn" class="b-link-green">好好学java</a>
                        <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                        <a href="/5w-zi-de-linux-zhi-shi-zong-jie.html" class="b-link-green">5W 字的 Linux 知识总结</a>
                    </p>
                </div>

            </div>
        </div>

        

        

        

        

        
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }
    /* valine 评论框增加背景图片 */
    #vcomments textarea {
        box-sizing: border-box;
        background: url("") 100% 100% no-repeat;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    /* 修复评论第一行位置错位 */
    .v .vlist .vcard {
    padding-top: 2.5em !important ;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <link rel="stylesheet" type="text/css" href="/libs//libs/jQuery-emoji/dist/css/jquery.emoji.css">
<script src="/libs//libs/jQuery-emoji/dist/js/jquery.emoji.min.js"></script>
<script src="/libs//libs/jQuery-emoji/dist/js/emoji.list.js"></script> -->
<script>
    new Valine({
        el: '#vcomments',
        appId: 'MxSNOS83TYWU3Opsy2GTW1ih-gzGzoHsz',
        appKey: '4XevOgmAxHEwVDnIKgvEUihB',
        notify: 'true' === 'true',
        verify: 'true' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '请畅所欲言吧，别害羞~',

    });

//     function parse_emoji() {
//     jQuery(".vcontent").emojiParse({
//       basePath: '/libs/jQuery-emoji/images/emoji',
//       icons: emojiLists   // 注：详见 js/emoji.list.js
//     });
//   }
  
//   setTimeout(function() {
//     // jQuery emoji 解析
//     parse_emoji();
//     // jquery emoji 初始化
//     jQuery(".veditor").emoji({
//       showTab: true,
//       animation: 'slide',
//       basePath: '/libs/jQuery-emoji/images/emoji',
//       icons: emojiLists  // 注：详见 js/emoji.list.js
//     });
//     jQuery(".vmore").on("click", function() {
//       setTimeout(function() {
//         parse_emoji();
//       }, 500);
//     });
//   }, 800)

</script>
        

        

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/springboot-ju-ran-you-44-chong-ying-yong-qi-dong-qi.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="SpringBoot 居然有 44 种应用启动器">
                        
                        <span class="card-title">SpringBoot 居然有 44 种应用启动器</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            点击上方 **好好学java **，选择 **星标 **公众号
重磅资讯、干货，第一时间送达
今日推荐：个人原创100W+访问量博客：点击前往，查看更多
啥是应用启动器？SpringBoot集成了spring的很多模块，比如tomcat、r
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock fa-fw icon-date"></i>2021-04-04
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%A5%BD%E5%A5%BD%E5%AD%A6java/" class="post-category" target="_blank">
                                    好好学java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/linux-fu-wu-qi-gao-bing-fa-diao-you-shi-zhan.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/6.jpg" class="responsive-img" alt="Linux 服务器高并发调优实战">
                        
                        <span class="card-title">Linux 服务器高并发调优实战</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            点击上方 **好好学java **，选择 **星标 **公众号
重磅资讯、干货，第一时间送达
今日推荐：个人原创100W+访问量博客：点击前往，查看更多
众所周知在默认参数情况下Linux对高并发支持并不好，主要受限于单进程最大打开文件数限
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock fa-fw icon-date"></i>2021-04-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%A5%BD%E5%A5%BD%E5%AD%A6java/" class="post-category" target="_blank">
                                    好好学java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>
    </div>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('500')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 好好学java<br />'
            + '作者: 好好学java<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>



<!--
<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
<script>
    const btw = new BTWPlugin();
    btw.init({
        id: 'container',
        blogId: '15305-1590684104111-518',
        name: '程序员的技术圈子',
        qrcode: 'http://image.ouyangsihai.cn/FtAUOeE5--1JTdcuuZFIhMuEUuJO',
        keyword: 'vip',
    });
</script>
-->

    </div>
    <div id="toc-aside" style="width: 310px;" class="expanded col l3 hide-on-med-and-down">
        <!-- 自定义右侧card：欧阳思海 -->
        <!-- <div id="my-card" style="background: ">
            
        </div> -->
        <!-- <div class="toc-widget">
            <div class="toc-title" style="display: none;"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;</div>
            <div id="toc-content"></div>
        </div> -->








        <aside class="col-lg-3" style="width: 300px;">

            <link rel="stylesheet" type="text/css" href="/css/my-aside.css">

            <!-- 关注公众号信息：欧阳思海 -->
            <div class="widget-wrap">
                <div class="widget bg-danger" style="color:whitesmoke; background-color: #419488">
                    <div class="card-front animated col s12 m12 l8 offset-l2 fadeInUp">
                        <div class="row">
                            <div class="col-md-5" style="text-align: center;">
                                <img class="adv" style="width: 95px; height: 95px;"
                                    src="http://image.ouyangsihai.cn/FtAUOeE5--1JTdcuuZFIhMuEUuJO">
                            </div>
                            <div class="col-md-7" style="text-align: center;">
                                <h2 style="font-size: 18px; 
                                    margin: 0; 
                                    padding: 0;
                                    border: 0; 
                                    outline: 0;
                                    font-weight: inherit;
                                    font-style: inherit;
                                    font-family: inherit;
                                    vertical-align: baseline;">关注公众号</h2>
                                 
                                <small style="font-size: 15px;">
                                    →「技术干货」每日推送 <br>
                                    →「回复资料」领取资料 <br>
                                    →「微信加群」每周福利 <br>
                                </small>
                            </div>
                        </div>
                    </div>

                    <!-- <div style="font-size: 0.8em;">
                        <a href="/assets/erweima.jpg" target="_blank"
                            style="color:orange;font-size: 14px;">点击添加我的微信，加入技术讨论群</a>
                        除公众号以外，我还会在以下平台发布内容：
                    </div>
                    -->

                    <div class="profile-block social-links col-md-7" style="text-align: center;">
                        <table style="align-items: center; 
                                        padding-left: 25px;">
                            <tbody>
                                <tr>
                                    <td style="margin: 0;
                                                padding: 0;
                                                border: 0;
                                                outline: 0;
                                                font-weight: inherit;
                                                font-style: inherit;
                                                font-family: inherit;
                                                vertical-align: baseline;"><a
                                            style="color: whitesmoke;font-size: 25px;"
                                            href="https://github.com/OUYANGSIHAI/JavaInterview" target="_blank" title="GitHub"
                                            class="tooltip">
                                            <img style="width: 22px;height: 22px;" src="/icons/github.svg"></a>
                                    </td>

                                    <td style="margin: 0;
                                                padding: 0;
                                                border: 0;
                                                outline: 0;
                                                font-weight: inherit;
                                                font-style: inherit;
                                                font-family: inherit;
                                                vertical-align: baseline;"><a
                                            style="color: whitesmoke;font-size: 25px;"
                                            href="https://www.zhihu.com/people/hai-hai-ren-sheng-50/activities"
                                            target="_blank" title="知乎" class="tooltip">
                                            <img style="width: 22px;" src="/icons/zhihu.svg"></a>
                                    </td>
                                    <td style="margin: 0;
                                                padding: 0;
                                                border: 0;
                                                outline: 0;
                                                font-weight: inherit;
                                                font-style: inherit;
                                                font-family: inherit;
                                                vertical-align: baseline;"><a
                                            style="color: whitesmoke;font-size: 25px;"
                                            href="https://blog.csdn.net/sihai12345" target="_blank" title="CSDN"
                                            class="tooltip">
                                            <img style="width: 18px;" src="/icons/CSDN.svg"></a>
                                    </td>
                                    <td style="margin: 0;
                                                padding: 0;
                                                border: 0;
                                                outline: 0;
                                                font-weight: inherit;
                                                font-style: inherit;
                                                font-family: inherit;
                                                vertical-align: baseline;"><a
                                            style="color: whitesmoke;font-size: 25px;"
                                            href="https://www.jianshu.com/u/12b0bd4c857c" target="_blank" title="简书"
                                            class="tooltip">
                                            <img style="width: 22px;" src="/icons/JianShu.svg"></a>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>


            

            <!-- custom rightside_link：热门文章推荐：欧阳思海 -->
            
            <div class="widget-wrap widget-panel">
                <p style="text-align: left;padding-bottom: 10px;line-height: 30px; font-size: 14px;">
                    
                    <a href="https://github.com/OUYANGSIHAI/JavaInterview" target="_blank">

                        <img src="/icons/hot.gif">

                        本人花费半年的时间总结的《 Java 面试指南》已拿腾讯等大厂 offer，已开源在 github ，欢迎 star！
                    </a><br>
                    
                    <a href="https://mp.weixin.qq.com/s/I0jimqziHqRNaIy0kXRCnw" target="_blank">

                        <img src="/icons/hot.gif">

                        2020 Java 1000G 最新学习资源，Java基础、Java项目实战、Java分布式等等！
                    </a><br>
                    
                    <a href="http://image.ouyangsihai.cn/FpB-dO6g-XU44mMrVlj7EL1y7Rs7" target="_blank">

                        <img src="/icons/hot.gif">

                        高级 Java 开发微信群，一起搞事情吧！
                    </a><br>
                    
                </p>
            </div>
            

            

            <!-- custom rightside_banner：右侧广告或者其他的栏目设置：欧阳思海 -->
            
            <div class="widget-wrap">
                <a href="https://github.com/OUYANGSIHAI/JavaInterview" target="_blank">
                    <img src="http://image.ouyangsihai.cn/FhhoEYMaNr6m0v8KhG8vSPgoREBV" style="width: 100%;">
                </a>
            </div>
            
            

            

            <!-- 右侧专栏分类：欧阳思海 -->
            
            <div class="widget-wrap widget-panel">
                <ul class="media-list">
                    
                    <li class="media">
                        <a href="/categories/MySQL的艺术世界/" target="_blank">
                            <div class="media-left">
                                <img class="media-object" src="http://image.ouyangsihai.cn/Fn3kQurieQ_0QUeqPmx5RW5i6R9n" style="width: 55px;">
                            </div>
                            <div class="media-body">
                                <h4 class="media-heading" style="margin-bottom: 10px; font-size: 100%;
                                                                    margin: 0;
                                                                    padding: 0;
                                                                    border: 0;
                                                                    outline: 0;
                                                                    font-weight: inherit;
                                                                    font-style: inherit;
                                                                    font-family: inherit;
                                                                    vertical-align: baseline;">
                                    MySQL 的系列文章，解决全部面试问题！
                                </h4>
                                <p>
                                    总共10篇文章，面试热门的锁、事务，通通解决了！
                                </p>
                            </div>
                        </a>
                    </li>
                    <hr>
                    
                    <li class="media">
                        <a href="/categories/深入理解Java虚拟机/" target="_blank">
                            <div class="media-left">
                                <img class="media-object" src="http://image.ouyangsihai.cn/FpcS21VWJOHSgGzKcpW3_xVTSEeN" style="width: 55px;">
                            </div>
                            <div class="media-body">
                                <h4 class="media-heading" style="margin-bottom: 10px; font-size: 100%;
                                                                    margin: 0;
                                                                    padding: 0;
                                                                    border: 0;
                                                                    outline: 0;
                                                                    font-weight: inherit;
                                                                    font-style: inherit;
                                                                    font-family: inherit;
                                                                    vertical-align: baseline;">
                                    深入理解 Java 虚拟机，面试必问
                                </h4>
                                <p>
                                    总共10篇文章，包括内存模型、GC算法、GC收集器等。
                                </p>
                            </div>
                        </a>
                    </li>
                    <hr>
                    
                </ul>
            </div>
            

            <!-- 右侧分类 -->
            <div class="widget-wrap widget-panel">
                <h3 class="widget-title">文章分类</h3>
                <div class="widget">
                    <ul class="category-list">
                        
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/趣聊数据结构与算法/">>
                                趣聊数据结构与算法</a><span class="category-list-count">6</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/职业生涯浅谈/">>
                                职业生涯浅谈</a><span class="category-list-count">33</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/Java项目分享/">>
                                Java项目分享</a><span class="category-list-count">1</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/Java面试经验/">>
                                Java面试经验</a><span class="category-list-count">4</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/我要进大厂/">>
                                我要进大厂</a><span class="category-list-count">1</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/好好学java/">>
                                好好学java</a><span class="category-list-count">1116</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/剑指offer/">>
                                剑指offer</a><span class="category-list-count">112</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/css/">>
                                css</a><span class="category-list-count">12</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/其他框架/">>
                                其他框架</a><span class="category-list-count">142</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/python其他/">>
                                python其他</a><span class="category-list-count">45</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/数据库相关/">>
                                数据库相关</a><span class="category-list-count">293</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/Java核心知识/">>
                                Java核心知识</a><span class="category-list-count">196</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/Java面试题/">>
                                Java面试题</a><span class="category-list-count">308</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/mybatis源码/">>
                                mybatis源码</a><span class="category-list-count">56</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/spring教程/">>
                                spring教程</a><span class="category-list-count">173</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/springboot教程/">>
                                springboot教程</a><span class="category-list-count">156</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/实战Activiti工作流/">>
                                实战Activiti工作流</a><span class="category-list-count">4</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/springcloud教程/">>
                                springcloud教程</a><span class="category-list-count">39</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/linux/">>
                                linux</a><span class="category-list-count">91</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/python框架/">>
                                python框架</a><span class="category-list-count">43</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/python基础/">>
                                python基础</a><span class="category-list-count">78</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/dubbo/">>
                                dubbo</a><span class="category-list-count">37</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/Java源码/">>
                                Java源码</a><span class="category-list-count">76</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/叽叽喳喳杂七杂八/">>
                                叽叽喳喳杂七杂八</a><span class="category-list-count">10</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/MySQL的艺术世界/">>
                                MySQL的艺术世界</a><span class="category-list-count">8</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/jquery/">>
                                jquery</a><span class="category-list-count">14</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/Java并发/">>
                                Java并发</a><span class="category-list-count">43</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/Java文章合辑/">>
                                Java文章合辑</a><span class="category-list-count">11</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/Java基础修炼/">>
                                Java基础修炼</a><span class="category-list-count">7</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/不一样的Java8/">>
                                不一样的Java8</a><span class="category-list-count">3</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/小程序开发的世界/">>
                                小程序开发的世界</a><span class="category-list-count">1</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/Java学习资源分享/">>
                                Java学习资源分享</a><span class="category-list-count">1</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/Java小学生漫游/">>
                                Java小学生漫游</a><span class="category-list-count">2</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/rocketmq源码解析/">>
                                rocketmq源码解析</a><span class="category-list-count">33</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/springmvc最新教程/">>
                                springmvc最新教程</a><span class="category-list-count">9</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/Java的Exception/">>
                                Java的Exception</a><span class="category-list-count">6</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/vue-js/">>
                                vue.js</a><span class="category-list-count">10</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/实战设计模式/">>
                                实战设计模式</a><span class="category-list-count">1</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/python数据处理/">>
                                python数据处理</a><span class="category-list-count">7</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/Java-Web闯关/">>
                                Java Web闯关</a><span class="category-list-count">7</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/springboot2-0最新教程/">>
                                springboot2.0最新教程</a><span class="category-list-count">11</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/netty/">>
                                netty</a><span class="category-list-count">16</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/rpc/">>
                                rpc</a><span class="category-list-count">13</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/拥抱大厂系列/">>
                                拥抱大厂系列</a><span class="category-list-count">6</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/eureka/">>
                                eureka</a><span class="category-list-count">19</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/分布式/">>
                                分布式</a><span class="category-list-count">6</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/中间件/">>
                                中间件</a><span class="category-list-count">23</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/Java基础/">>
                                Java基础</a><span class="category-list-count">1</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/带你学Python/">>
                                带你学Python</a><span class="category-list-count">10</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/使用技术工具/">>
                                使用技术工具</a><span class="category-list-count">1</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/mycat源码/">>
                                mycat源码</a><span class="category-list-count">5</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/深入理解Java虚拟机/">>
                                深入理解Java虚拟机</a><span class="category-list-count">8</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/spring源码/">>
                                spring源码</a><span class="category-list-count">2</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/Java集合源码分析/">>
                                Java集合源码分析</a><span class="category-list-count">1</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/github的repo/">>
                                github的repo</a><span class="category-list-count">1</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/Java框架深究/">>
                                Java框架深究</a><span class="category-list-count">1</span>
                        </li>
                        
                        <li class="category-list-item"><a class="category-list-link" href="categories/分布式架构/">>
                                分布式架构</a><span class="category-list-count">2</span>
                        </li>
                        
                        
                    </ul>
                </div>
            </div>

        </aside>









    </div>
</div>

<!-- TOC 悬浮按钮. 修改成永远不显示：欧阳思海-->




<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4, h5'
        });

        console.log('============');

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

                        
            /* 修复文章卡片 div 的宽度. */
            let fixPostCardWidth = function (srcId, targetId) {
                let srcDiv = $('#' + srcId);
                if (srcDiv.length === 0) {
                    return;
                }

                let w = srcDiv.width();
                if (w >= 450) {
                    w = w + 21;
                } else if (w >= 350 && w < 450) {
                    w = w + 18;
                } else if (w >= 300 && w < 350) {
                    w = w + 16;
                } else {
                    w = w + 14;
                }
                $('#' + targetId).width(w);
            };

            // 切换TOC目录展开收缩的相关操作.
            // 修改右侧边栏功能：欧阳思海
            const expandedClass = 'expanded';
            let $tocAside = $('#toc-aside');
            let $mainContent = $('#main-content');

            $('#floating-toc-btn .btn-floating').click(function () {
                if ($tocAside.hasClass(expandedClass)) {
                    $tocAside.removeClass(expandedClass).slideUp(500);
                    $mainContent.removeClass('l9');
                } else {
                    $tocAside.addClass(expandedClass).slideDown(500);
                    $mainContent.addClass('l9');
                }
                fixPostCardWidth('artDetail', 'prenext-posts');
            });
                        
                    });
</script>
    

</main>


        <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            
	    Copyright&copy; 2019 <a href="https://www.java1000.com/" target="_blank"> 好好学java </a>维护. 网站备案/许可证号：赣ICP备17007984号-3
            <br>
            <span id="sitetime"></span>
            <br>

            

            
                    <!-- 
                        <span id="busuanzi_container_site_pv" style='display:none'></span>
                        总访问量: <span id="busuanzi_value_site_pv" class="white-color"></span>
                    
        
                    
                        <span id="busuanzi_container_site_uv" style='display:none'></span>
                        人次&nbsp; | &nbsp;访客人数: <span id="busuanzi_value_site_uv" class="white-color"></span> 人
                     -->
                        <!-- 修改计数：欧阳思海 -->
                    
                        <span id="busuanzi_container_site_pv" style='display:inline'>
                            <i class="fa fa-heart-o"></i>
                            本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                        </span>
                    
                    
                        <span id="busuanzi_container_site_uv" style='display:none'>
                            人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                        </span>
                    
    
            

            
                &nbsp; | &nbsp;字数统计:&nbsp;
                <span class="white-color">8290.3k</span> 字
            

            
            <br>

        </div>

        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/OUYANGSIHAI/JavaInterview" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-code-branch"></i>
    </a>


 
    <a href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=1446037005@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>




    <a href="https://zhihu.com/people/hai-hai-ren-sheng-50/activities" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-inverse">知</i>
    </a>









    <a href="https://blog.ouyangsihai.cn/sitemap.xml" class="tooltipped" target="_blank" data-tooltip="站点地图" data-position="top" data-delay="50">
        <i class="fa fa-sitemap"></i>
    </a>



    <a href="https://blog.ouyangsihai.cn/friends" class="tooltipped" target="_blank" data-tooltip="友情链接" data-position="top" data-delay="50">
        <i class="fa fa-address-book"></i>
    </a>
</div>

    </div>
</footer>

<div class="progress-bar"></div>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();

        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */

        var t1 = Date.UTC(2019, 08, 10, 00, 00, 00); //北京时间2019-8-1 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes *
            minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours +
            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒" ;
    } /*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

<!-- 修改计数：欧阳思海 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);  // 50ms周期检测函数
        var pvcountOffset = 1005469;  // 初始化首次数据
        var uvcountOffset = 250804;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int); // 停止检测
            }
        }
    });
</script>




        <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    console.log("lets go！");
    console.log("/");
    searchFunc("/" + "search.json", 'searchInput', 'searchResult');
});
</script>
        <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


        <script src="/libs/materialize/materialize.min.js"></script>
        <script src="/libs/masonry/masonry.pkgd.min.js"></script>
        <script src="/libs/aos/aos.js"></script>
        <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
        <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
        <script src="/js/matery.js"></script>

        <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-149362573-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'UA-149362573-1');
</script>



        
            <script src="/libs/others/clicklove.js"></script>
        

        
            <script async src="/libs/others/busuanzi.pure.mini.js"></script>
        

        <!-- 洪卫 shw2018 add 2019.08.28 -->
        <script type="text/javascript">
            var OriginTitile = document.title,
                st;
            document.addEventListener("visibilitychange", function () {
                document.hidden ? (document.title = "看不见我🙈~看不见我🙈~", clearTimeout(st)) : (document.title =
                    "(๑•̀ㅂ•́) ✧被发现了～", st = setTimeout(function () {
                        document.title = OriginTitile
                    }, 3e3))
            })
        </script>

        <!-- 鼠标点击烟花爆炸效果  洪卫 shw2018 add 2019.09.09 -->
        

        <!-- 背景雪花飘落特效洪卫 shw2018 add 2019.09.10 -->
        

        <!-- 鼠标点击文字特效 洪卫 shw2018 add 2019.09.10-->
        

        <!-- 背景雪花飘落特效 洪卫 shw2018 add 2019.09.10 -->
        

        <!-- 在线聊天工具  洪卫 shw2018 add 2019.09.11 -->
        

        <!-- 背景 canvas-nest  洪卫 shw 2018  add 2019.09.15-->
        

        <!-- 背景静止彩带  洪卫 shw 2018  add 2019.09.15-->
        

        <!-- 背景动态彩带 洪卫 shw 2018  add 2019.09.15-->
        

    </body>
</html>